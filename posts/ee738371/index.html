<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>Python 数据处理：NumPy库的使用 | 小嗷犬</title><meta name="keywords" content="数据分析,Python"><meta name="author" content="小嗷犬"><meta name="copyright" content="小嗷犬"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Python 数据处理：NumPy库的使用"><meta name="application-name" content="Python 数据处理：NumPy库的使用"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Python 数据处理：NumPy库的使用"><meta property="og:url" content="https://blog.marquis.eu.org/posts/ee738371/index.html"><meta property="og:site_name" content="小嗷犬"><meta property="og:description" content="NumPy简介 NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。 NumPy的部分功能如下:  ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。 用于对整组数据进行快速运"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/7db7ab3c1cf84fea997611e72efe0b3f.png"><meta property="article:author" content="小嗷犬"><meta property="article:tag" content="Python, 人工智能, 深度学习, 爬虫, 数据分析, 数据可视化, 小嗷犬, PWA"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/7db7ab3c1cf84fea997611e72efe0b3f.png"><meta name="description" content="NumPy简介 NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。 NumPy的部分功能如下:  ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。 用于对整组数据进行快速运"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.marquis.eu.org/posts/ee738371/"><link rel="preconnect" href="//cdn.cbd.int"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="7oHto6XqE_zXYM7itwHoZTeb47PULzcAxenBeT1h-c4"><meta name="baidu-site-verification" content="codeva-izBOFPih2F"><meta name="msvalidate.01" content="390C5F1424AB7444F1B8E05DA02232BF"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"><link rel="mask-icon" href="/img/siteicon/apple-touch-icon.png" color="#5bbad5"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/favicon-16x16.png"><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?368c140290209ced69f65d67bf17e5fd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={linkPageTop:{enable:!0,title:"与数百名博主无限进步",addFriendPlaceholder:"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},peoplecanvas:void 0,postHeadAiDescription:{enable:!0,gptName:"小嗷犬",mode:"local",switchBtn:!1,btnLink:"https://afdian.net/item/886a79d4db6711eda42a52540025c377",randomNum:3,basicWordCount:1e3,key:"xxxx",Referer:"https://xx.xx/"},diytitle:{enable:!0,leaveTitle:"w(ﾟДﾟ)w 不要走！再看看嘛！",backTitle:"♪(^∇^*)欢迎肥来！"},LA51:{enable:!0,ck:"JwZrZwQa4gtWzwsr",LingQueMonitorID:"JwcZGiBSGG3rSvij"},greetingBox:{enable:!0,default:"晚上好👋",list:[{greeting:"晚安😴",startTime:0,endTime:5},{greeting:"早上好鸭👋, 祝你一天好心情！",startTime:6,endTime:9},{greeting:"上午好👋, 状态很好，鼓励一下～",startTime:10,endTime:10},{greeting:"11点多啦, 在坚持一下就吃饭啦～",startTime:11,endTime:11},{greeting:"午安👋, 宝贝",startTime:12,endTime:14},{greeting:"🌈充实的一天辛苦啦！",startTime:14,endTime:18},{greeting:"19点喽, 奖励一顿丰盛的大餐吧🍔。",startTime:19,endTime:19},{greeting:"晚上好👋, 在属于自己的时间好好放松😌~",startTime:20,endTime:24}]},twikooEnvId:"https://twikoo.marquis.eu.org/",commentBarrageConfig:{enable:!0,maxBarrage:1,barrageTime:4e3,accessToken:"",mailMd5:"29ae50b4bc2db4bc06b67953cffcde91"},root:"/",preloader:{source:3},friends_vue_info:void 0,navMusic:!0,mainTone:{mode:"api",api:"https://img2color.marquis.eu.org/api?img=",cover_change:!0},authorStatus:{skills:["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},algolia:{appId:"DVYRTF6D9Z",apiKey:"f2a8d629317821324cdf3875087d3364",indexName:"blog",hits:{per_page:6},languages:{input_placeholder:"输入关键词后按下回车查找",hits_empty:"找不到您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，用时 ${time} 毫秒"}},localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简",rightMenuMsgToTraditionalChinese:"转为繁体",rightMenuMsgToSimplifiedChinese:"转为简体"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"这篇文章距离上次更新已经过去了",messageNext:"天，其中的某些内容可能不再适用了，请谨慎阅读。"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:400},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,simplehomepage:!0,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{copy:!0,copyrightEbable:!0,limitCount:50,languages:{author:"作者: 小嗷犬",link:"链接: ",source:"来源: 小嗷犬",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",copySuccess:"复制成功，复制和转载请标注本文地址"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#425AEF",bgDark:"#1f1f1f",position:"top-center"},source:{justifiedGallery:{js:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js",css:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,shortcutKey:void 0,autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"小嗷犬",title:"Python 数据处理：NumPy库的使用",postAI:"本文介绍了 Python 数据处理中 NumPy 库的使用。NumPy 是一种多维数组对象，可以进行各种数组运算和索引操作。文章详细介绍了创建ndarray、数据类型、基本的索引和切片、布尔型索引、花式索引、数组转置和轴对换等操作。此外，还介绍了通用函数、排序、唯一化以及其它的集合逻辑等方法，用于将条件逻辑表述为数组运算，并提供了数学和统计方法。最后，文章还介绍了用于数组的文件输入输出、线性代数、伪随机数生成、高级数组操作等内容。",pageFillDescription:"NumPy简介, NumPy的ndarray：一种多维数组对象, 创建ndarray, ndarray的数据类型, NumPy数组的运算, 基本的索引和切片, 切片索引, 布尔型索引, 花式索引, 数组转置和轴对换, 通用函数：快速的元素级数组函数, 指定输出, 聚合, 外积, 利用数组进行数据处理, 将条件逻辑表述为数组运算, 数学和统计方法, 用于布尔型数组的方法, 排序, 唯一化以及其它的集合逻辑, 用于数组的文件输入输出, 线性代数, 伪随机数生成, 高级数组操作, 数组重塑, C和Fortran顺序, 数组的合并和拆分, 元素的重复操作：tile和repeat, 广播, 广播规则, 通过广播设置数组的值简介的简称是数值计算最重要的基础包大多数提供科学计算的包都是用的数组作为构建基础的部分功能如下一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组用于对整组数据进行快速运算的标准数学函数无需编写循环用于读写磁盘数据的工具以及用于操作内存映射文件的工具线性代数随机数生成以及傅里叶变换功能用于集成由等语言编写的代码的对于数值计算特别重要的原因之一是因为它可以高效处理大数组的数据这是因为是在一个连续的内存块中存储数据独立于其他内置对象的语言编写的算法库可以操作内存而不必进行类型检查或其它前期工作比起的内置序列数组使用的内存更少可以在整个数组上执行复杂的计算而不需要的循环在中运行以下代码可以比较数组和列表的数据运算效率考察一个包含一百万整数的数组和一个等价的列表各个序列分别乘以其中衡量的是用来执行程序的时间从计算开始到计算结束等待的时间的一种多维数组对象最重要的一个特点就是其维数组对象即该对象是一个快速而灵活的大数据集容器你可以利用这种数组对整块数据执行一些数学运算其语法跟标量元素之间的运算一样对于原生的列表这些乘法和加法的规则有点不一样是一个通用的同构数据多维容器也就是说其中的所有元素必须是相同类型的记录数组除外每个数组都有一个一个表示各维度大小的元组和一个一个用于说明数组数据类型的对象创建创建数组最简单的办法就是使用函数它接受一切序列型的对象包括其他数组然后产生一个新的含有传入数据的数组以一个列表的转换为例嵌套序列比如由一组等长列表组成的列表将会被转换为一个多维数组除之外还有一些函数也可以新建数组比如和分别可以创建指定长度或形状的全或全数组可以创建一个没有任何具体值的数组要用这些方法创建多维数组只需传入一个表示形状的元组即可是内置函数的数组版下表列出了一些数组创建函数由于关注的是数值计算因此如果没有特别指定数据类型基本都是浮点数函数描述将输入数据列表元组数组或其它序列类型转换为要么推断出要么特别指定默认直接复制输入数据将输入转换为如果输入本身就是一个就不进行复制类似于内置的但返回的是一个而不是列表根据指定的形状和创建一个全数组以另一个数组为参数并根据其形状和创建一个全数组类似于和只不过产生的是全数组而已创建新数组只分配内存空间但不填充任何值用中的所有值根据指定的形状和创建一个数组使用另一个数组用相同的形状和创建创建一个正方的单位矩阵对角线为其余为的数据类型数据类型是一个特殊的对象它含有将一块内存解释为特定数据类型所需的信息数值型的命名方式相同一个类型名如或后面跟一个用于表示各元素位长的数字标准的双精度浮点值即中的对象需要占用字节即位因此该类型在中就记作下表列出了所支持的全部数据类型类型类型代码描述有符号和无符号的位个字节整型有符号和无符号的位个字节整型有符号和无符号的位个字节整型有符号和无符号的位个字节整型半精度浮点数或标准的单精度浮点数与的兼容或标准的双精度浮点数与的和的对象兼容或扩展精度浮点数分别用两个位位或位浮点数表示的复数存储和值的布尔类型对象类型固定长度的字符串类型每个字符个字节例如要创建一个长度为的字符串应使用固定长度的类型字节数由平台决定跟字符串的定义方式一样如可以通过的方法明确地将一个数组从一个转换成另一个如果将浮点数转换成整数则小数部分将会被截取删除如果某字符串数组表示的全是数字也可以用将其转换为数值形式数组的运算数组很重要因为它使你不用编写循环即可对数据执行批量运算用户称其为矢量化大小相等的数组之间的任何算术运算都会将运算应用到元素级数组与标量的算术运算会将标量值传播到各个元素大小相同的数组之间的比较会生成布尔值数组基本的索引和切片数组的索引是一个内容丰富的主题因为选取数据子集或单个元素的方式有很多一维数组很简单从表面上看它们跟列表的功能差不多跟列表最重要的区别在于数组切片是原始数组的视图这意味着数据不会被复制视图上的任何修改都会直接反映到源数组上先创建一个的切片现在当修改中的值变动也会体现在原始数组中切片会给数组中的所有值赋值再来试试如果你想要得到的是切片的一份副本而非视图就需要明确地进行复制操作例如对于高维度数组能做的事情更多在一个二维数组中各索引位置上的元素不再是标量而是一维数组因此可以对各个元素进行递归访问但这样需要做的事情有点多你可以传入一个以逗号隔开的索引列表来选取单个元素也就是说下面两种方式是等价的二维数组的索引方式轴作为行轴作为列在多维数组中如果省略了后面的索引则返回对象会是一个维度低一点的它含有高一级维度上的所有数据因此在数组中标量值和数组都可以被赋值给切片索引的切片语法跟列表这样的一维对象差不多对于之前的二维数组其切片方式稍显不同它是沿着第轴即第一个轴切片的也就是说切片是沿着一个轴向选取元素的表达式可以被认为是选取的前两行可以一次传入多个切片就像传入多个索引那样像这样进行切片时只能得到相同维数的数组视图通过将整数索引和切片混合可以得到低维度的切片例如可以选取第二行的前两列相似的还可以选择第三列的前两行只有冒号表示选取整个轴因此你可以像下面这样只对高维轴进行切片对切片表达式的赋值操作也会被扩散到整个选区布尔型索引来看这样一个例子假设我们有一个用于存储数据的数组以及一个存储姓名的数组含有重复项在这里我将使用中的函数生成一些正态分布的随机数据假设每个名字都对应数组中的一行而我们想要选出对应于名字的所有行跟算术运算一样数组的比较运算如也是矢量化的因此对和字符串的比较运算将会产生一个布尔型数组这个布尔型数组可用于数组索引布尔型数组的长度必须跟被索引的轴长度一致此外还可以将布尔型数组跟切片整数混合使用下面的例子选取了的行并索引了列要选择除以外的其他值既可以使用不等于符号也可以通过对条件进行否定选取这三个名字中的两个需要组合应用多个布尔条件使用与或之类的布尔算术运算符即可通过布尔型数组设置值是一种经常用到的手段为了将中的所有负值都设置为我们只需通过一维布尔数组设置整行或列的值也很简单花式索引花式索引是一个术语它指的是利用整数数组进行索引假设我们有一个数组为了以特定顺序选取行子集只需传入一个用于指定顺序的整数列表或即可使用负数索引将会从末尾开始选取行一次传入多个索引数组会有一点特别它返回的是一个一维数组其中的元素对应各个索引元组最终选出的是元素和无论数组是多少维的花式索引总是一维的这个花式索引的行为可能会跟某些用户的预期不一样选取矩阵的行列子集应该是矩形区域的形式才对下面是得到该结果的一个办法记住花式索引跟切片不一样它总是将数据复制到新数组中数组转置和轴对换转置是重塑的一种特殊形式它返回的是源数据的视图不会进行任何复制操作数组不仅有方法还有一个特殊的属性在进行矩阵计算时经常需要用到该操作比如利用计算矩阵内积简单的转置可以使用它其实就是进行轴对换而已还有一个方法它需要接受一对轴编号通用函数快速的元素级数组函数通用函数即是一种对中的数据执行元素级运算的函数你可以将其看做简单函数接受一个或多个标量值并产生一个或多个标量值的矢量化包装器许多都是简单的元素级变体如和这些都是一元另外一些如或接受个数组因此也叫二元并返回一个结果数组有些可以返回多个数组就是一个例子它是内置函数的矢量化版本它会返回浮点数数组的小数和整数部分可以接受一个可选参数这样就能在数组原地进行操作下表列出了一些一元和二元一元描述计算整数浮点数或复数的绝对值对于非复数值可以使用更快的计算各元素的平方根相当于计算各元素的平方相当于计算各元素的指数分别为自然对数底数为底数为的底数为的计算各元素的正负号正数零负数计算各元素的值即大于等于该值的最小整数计算各元素的值即小于等于该值的最大整数反三角函数计算各元素的真值相当于二元描述将数组中对应的元素相加从第一个数组中减去第二个数组中的元素数组元素相乘除法或向下圆整除法丢弃余数对第一个数组中的元素根据第二个数组中的相应元素计算元素级的最大值计算将忽略元素级的最小值计算将忽略元素级的求模计算除法的余数将第二个数组中的值的符号复制给第一个数组中的值指定输出在进行大量运算时指定一个用于存放运算结果的数组时非常有用的不同于创建临时数组可以用这个特性将计算结果直接写入到期望的存储位置这样在进行较大数据运算时可以有效节约内存所有的通用函数都可以通过参数来指定计算结果的存放位置这个特性也可以被用作数组视图例如可以将计算结果写入指定数组的每隔一个元素的位置聚合可以使用任何通用函数的方法该方法会对给定的元素和操作重复执行直至得到单个的结果类似的还有可以存储每次计算的中间结果外积任何通用函数都可以用方法获得两个不同输入数组所有元素对的函数运算结果利用数组进行数据处理假设我们想要在一组值网格型上计算函数函数接受两个一维数组并产生两个二维矩阵对应于两个数组中所有的对现在对该函数的求值运算就好办了把这两个数组当做两个浮点数那样编写表达式即可将条件逻辑表述为数组运算函数是三元表达式的矢量化版本假设我们有一个布尔数组和两个值数组假设我们想要根据中的值选取和的值当中的值为时选取的值否则从中选取列表推导式的写法应该如下所示若使用则可以将该功能写得非常简洁在数据分析工作中通常用于根据另一个数组而产生一个新的数组假设有一个由随机数据组成的矩阵你希望将所有正值替换为将所有负值替换为若利用则会非常简单使用可以将标量和数组结合起来例如可用常数替换中所有正的值去除异常值例如在成绩列表中将所有小于的成绩改为所有大于的成绩改为数学和统计方法可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算以及标准差等聚合计算通常叫做约简既可以当做数组的实例方法调用也可以当做顶级函数使用和这类的函数可以接受一个选项参数用于计算该轴向上的统计值最终结果是一个少一维的数组这里是计算行的平均值是计算每列的和关键字指定的时数组将会被折叠的维度而不是将要返回的维度因此指定意味着第个轴将要被折叠对于二维数组来说这意味着每一列的值都将被聚合其他如和之类的方法则不聚合而是产生一个由中间结果组成的数组在多维数组中累加函数如返回的是同样大小的数组但是会根据每个低维的切片沿着标记轴计算部分聚类下表列出了全部的基本数组统计方法方法描述对数组中全部或某轴向的元素求和零长度的数组的为算术平均数零长度的数组的为分别为标准差和方差自由度可调默认为最大值和最小值分别为最大和最小元素的索引所有元素的累计和所有元素的累计积用于布尔型数组的方法在上面这些方法中布尔值会被强制转换为和因此经常被用来对布尔型数组中的值计数另外还有两个方法和它们对布尔型数组非常有用用于测试数组中是否存在一个或多个而则检查数组中所有值是否都是排序跟内置的列表类型一样数组也可以通过方法就地排序多维数组可以在任何一个轴向上进行排序只需将轴编号传给即可顶级方法返回的是数组的已排序副本而就地排序则会修改数组本身计算数组分位数最简单的办法是对其进行排序然后选取特定位置的值唯一化以及其它的集合逻辑提供了一些针对一维的基本集合运算最常用的可能要数了它用于找出数组中的唯一值并返回已排序的结果用于测试一个数组中的值在另一个数组中的成员资格返回一个布尔型数组下表列出了中的集合函数方法描述计算中的唯一元素并返回有序结果计算和中的公共元素并返回有序结果计算和的并集并返回有序结果得到一个表示的元素是否包含于的布尔型数组集合的差即元素在中且不在中集合的对称差即存在于一个数组中但不同时存在于两个数组中的元素用于数组的文件输入输出能够读写磁盘上的文本数据或二进制数据这一小节只讨论的内置二进制格式因为更多的用户会使用或其它工具加载文本或表格数据和是读写磁盘数组数据的两个主要函数默认情况下数组是以未压缩的原始二进制格式保存在扩展名为的文件中的通过可以将多个数组保存到一个未压缩文件中将数组以关键字参数的形式传入即可如果要将数据压缩可以使用线性代数线性代数如矩阵乘法矩阵分解行列式以及其他方阵数学等是任何数组库的重要组成部分提供了一个用于矩阵乘法的函数既是一个数组方法也是命名空间中的一个函数等价于一个二维数组跟一个大小合适的一维数组的矩阵点积运算之后将会得到一个一维数组符也可以用作中缀运算符进行矩阵乘法中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西它们跟和等语言所使用的是相同的行业标准线性代数库如可能有取决于你的版本等下表列出了一些最常用的线性代数函数函数描述以一维数组的形式返回方阵的对角线或非对角线元素或将一维数组转换为方阵非对角线元素为矩阵乘法计算对角线元素的和计算矩阵行列式计算方阵的特征值和特征向量计算方阵的逆计算矩阵的伪逆计算分解计算奇异值分解解线性方程组其中为一个方阵计算的最小二乘解伪随机数生成模块对内置的进行了补充增加了一些用于高效生成多种概率分布的样本值的函数例如你可以用来得到一个标准正态分布的样本数组内置的模块则只能一次生成一个样本值从下面的测试结果中可以看出如果需要产生大量样本值快了不止一个数量级我们说这些都是伪随机数是因为它们都是通过算法基于随机数生成器种子在确定性的条件下生成的你可以用的更改随机数生成种子的数据生成函数使用了全局的随机种子要避免全局状态你可以使用创建一个与其它隔离的随机数生成器下表列出了中的部分函数函数描述确定随机数生成器的种子返回一个序列的随机排列或返回一个随机排列的范围对一个序列就地随机排列产生均匀分布的样本值从给定的上下限范围内随机选取整数产生正态分布平均值为标准差为的样本值类似于接口产生二项分布的样本值产生正态高斯分布的样本值产生分布的样本值产生卡方分布的样本值产生分布的样本值产生在中均匀分布的样本值高级数组操作除花式索引切片布尔条件取子集等操作之外数组的操作方式还有很多虽然中的高级函数可以处理数据分析工作中的许多重型任务但有时你还是需要编写一些在现有库中找不到的数据算法数组重塑多数情况下你可以无需复制任何数据就将数组从一个形状转换为另一个形状只需向数组的实例方法传入一个表示新形状的元组即可实现该目的例如假设有一个一维数组我们希望将其重新排列为一个矩阵结果见图多维数组也能被重塑作为参数的形状的其中一维可以是它表示该维度的大小由数据本身推断而来与将一维数组转换为多维数组的运算过程相反的运算通常称为扁平化或散开对应的函数为和如果结果中的值与原始数组相同不会产生源数据的副本方法的行为类似于只不过它总是返回数据的副本和顺序允许你更为灵活地控制数据在内存中的布局默认情况下数组是按行优先顺序创建的在空间方面这就意味着对于一个二维数组每行中的数据项是被存放在相邻内存位置上的另一种顺序是列优先顺序它意味着每列中的数据项是被存放在相邻内存位置上的像和这样的函数都可以接受一个表示数组数据存放顺序的参数一般可以是或还有和等不常用的选项具体请参考的文档上一小节的图片对此进行了说明数组的合并和拆分可以按指定轴将一个由数组组成的序列如元组列表等连接到一起对于常见的连接操作提供了一些比较方便的方法如和因此上面的运算还可以表达为与此相反用于将一个数组沿指定轴拆分为多个数组传入到的值指示在哪个索引处分割数组下表列出了所有关于数组连接和拆分的函数其中有些是专门为了方便常见的连接运算而提供的函数描述最一般化的连接沿一条轴连接一组数组以面向行的方式对数组进行堆叠沿轴以面向列的方式对数组进行堆叠沿轴类似于但是会先将一维数组转换为二维列向量以面向深度的方式对数组进行堆叠沿轴沿指定轴在指定的位置拆分数组的便捷化函数分别沿轴轴轴进行拆分元素的重复操作和对数组进行重复以产生更大数组的工具主要是和这两个函数会将数组中的各个元素重复一定次数从而产生一个更大的数组默认情况下如果传入的是一个整数则各元素就都会重复那么多次如果传入的是一组整数则各元素就可以重复不同的次数对于多维数组还可以让它们的元素沿指定轴重复同样在对多维进行重复时也可以传入一组整数这样就会使各切片重复不同的次数的功能是沿指定轴向堆叠数组的副本你可以形象地将其想象成铺瓷砖第二个参数是瓷砖的数量对于标量瓷砖是水平铺设的而不是垂直铺设它可以是一个表示铺设布局的元组广播广播指的是不同形状的数组之间的算术运算的执行方式它是一种非常强大的功能但也容易令人误解即使是经验丰富的老手也是如此将标量值跟数组合并时就会发生最简单的广播看一个例子我们可以通过减去列平均值的方式对数组的每一列进行距平化处理这个问题解决起来非常简单下图形象地展示了该过程用广播的方式对行进行距平化处理会稍微麻烦一些幸运的是只要遵循一定的规则低维度的值是可以被广播到数组的任意维度的比如对二维数组各列减去行平均值广播规则如果两个数组的维度数不相同那么小维度数组的形状将会在最左边补如果两个数组的形状在任何一个维度上都不匹配那么数组的形状会沿着维度为的维度扩展以匹配另外一个数组的形状如果两个数组的形状在任何一个维度上都不匹配并且每一偶任何一个维度等于那么会引发异常根据规则数组的维度数更小所以在其左边补根据规则第一个维度不匹配因此扩展这个维度以匹配数组这样两个数组的形状匹配了他们最终的形状都是对于三维的情况在三维中的任何一维上广播其实也就是将数据重塑为兼容的形状而已下图说明了要在三维数组各维度上广播的形状需求于是就有了一个非常普遍的问题尤其是在通用算法中即专门为了广播而添加一个长度为的新轴虽然是一个办法但插入轴需要构造一个表示新形状的元组这是一个很无聊的过程因此数组提供了一种通过索引机制插入轴的特殊语法下面这段代码通过特殊的属性以及全切片来插入新轴因此如果我们有一个三维数组并希望对轴进行距平化那么只需要编写下面这样的代码就可以了通过广播设置数组的值算术运算所遵循的广播原则同样也适用于通过索引机制设置数组值的操作对于最简单的情况我们可以这样做但是假设我们想要用一个一维数组来设置目标数组的各列只要保证形状兼容就可以了",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-10-07 21:00:34",postMainColor:"#8292cd"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:(e,t,a)=>{if(0===a)return;const o={value:t,expiry:Date.now()+864e5*a};localStorage.setItem(e,JSON.stringify(o))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const a=JSON.parse(t);if(!(Date.now()>a.expiry))return a.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((a,o)=>{const c=document.createElement("script");c.src=e,c.async=!0,c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},Object.keys(t).forEach((e=>{c.setAttribute(e,t[e])})),document.head.appendChild(c)})),e.getCSS=(e,t=!1)=>new Promise(((a,o)=>{const c=document.createElement("link");c.rel="stylesheet",c.href=e,t&&(c.id=t),c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},document.head.appendChild(c)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#18171d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#f7f9fe")};const t=saveToLocal.get("theme"),a=window.matchMedia("(prefers-color-scheme: dark)").matches,o=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!a&&!o&&!c;if(void 0===t){if(o)activateLightMode();else if(a)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((e=>{void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const d=saveToLocal.get("aside-status");void 0!==d&&("hide"===d?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="referrer" content="never"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/highlight-one-dark.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="alternate" href="/atom.xml" title="小嗷犬" type="application/atom+xml"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avatar/2.png"><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),setTimeout((function(){preloader.endLoading()}),1e4),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://marquis.eu.org/" title="个人主页"><img class="back-menu-item-icon" src="/img/avatar/1.png" alt="个人主页"><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" href="https://blog.marquis.eu.org/" title="个人博客"><img class="back-menu-item-icon" src="/img/avatar/2.png" alt="个人博客"><span class="back-menu-item-text">个人博客</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小嗷犬</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="fas fa-chart-bar faa-tada"></i> <span>统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8947107806&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i> <span>相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/favorites/"><i class="fas fa-star faa-tada"></i> <span>收藏夹</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size:.9em"></i> <span>装备栏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i> <span>友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i> <span>关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size:.9em"></i> <span>闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i> <span>随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i> <span>搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole()"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/reward/wechat.png" target="_blank"><img class="post-qr-code-img" alt="WeChat Pay" src="/img/reward/wechat.png"></a><div class="post-qr-code-desc">WeChat Pay</div></li><li class="reward-item"><a href="/img/reward/alipay.png" target="_blank"><img class="post-qr-code-img" alt="Alipay" src="/img/reward/alipay.png"></a><div class="post-qr-code-desc">Alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size:1.05rem">C<sup>1</sup></a><a href="/tags/CPP/" style="font-size:1.05rem">CPP<sup>5</sup></a><a href="/tags/LaTeX/" style="font-size:1.05rem">LaTeX<sup>4</sup></a><a href="/tags/Linux/" style="font-size:1.05rem">Linux<sup>1</sup></a><a href="/tags/MATLAB/" style="font-size:1.05rem;font-weight:500;color:var(--anzhiyu-lighttext)">MATLAB<sup>28</sup></a><a href="/tags/Markdown/" style="font-size:1.05rem">Markdown<sup>5</sup></a><a href="/tags/Python/" style="font-size:1.05rem;font-weight:500;color:var(--anzhiyu-lighttext)">Python<sup>43</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size:1.05rem">前端<sup>1</sup></a><a href="/tags/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB/" style="font-size:1.05rem">动作识别<sup>2</sup></a><a href="/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/" style="font-size:1.05rem">多任务<sup>1</sup></a><a href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/" style="font-size:1.05rem">多模态<sup>41</sup></a><a href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" style="font-size:1.05rem">大模型<sup>44</sup></a><a href="/tags/%E5%B0%91%E6%A0%B7%E6%9C%AC/" style="font-size:1.05rem">少样本<sup>4</sup></a><a href="/tags/%E5%BE%AE%E8%B0%83/" style="font-size:1.05rem">微调<sup>11</sup></a><a href="/tags/%E6%89%8B%E8%AF%AD%E7%BF%BB%E8%AF%91/" style="font-size:1.05rem">手语翻译<sup>21</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:1.05rem">操作系统<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" style="font-size:1.05rem">数学建模<sup>20</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size:1.05rem">数据分析<sup>5</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/" style="font-size:1.05rem">数据可视化<sup>2</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size:1.05rem">机器学习<sup>8</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size:1.05rem">深度学习<sup>19</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size:1.05rem">爬虫<sup>5</sup></a><a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" style="font-size:1.05rem">程序设计<sup>11</sup></a><a href="/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" style="font-size:1.05rem">论文笔记<sup>66</sup></a></div></div><hr></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多"><i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">21</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">22</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" tabindex="-1" itemprop="url"><span><i class="anzhiyufont anzhiyu-icon-hashtag"></i> 数据分析</span></a><a class="article-meta__tags" href="/tags/Python/" tabindex="-1" itemprop="url"><span><i class="anzhiyufont anzhiyu-icon-hashtag"></i> Python</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Python 数据处理：NumPy库的使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-08-26T13:33:00.000Z" title="发表于 2022-08-26 21:33:00">2022-08-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-07T13:00:34.000Z" title="更新于 2023-10-07 21:00:34">2023-10-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">10.5k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" data-flag-title="Python 数据处理：NumPy库的使用"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator"></span><span class="post-meta-position" title="作者IP属地为成都"><i class="anzhiyufont anzhiyu-icon-location-dot"></i> 成都</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/ee738371/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img-blog.csdnimg.cn/7db7ab3c1cf84fea997611e72efe0b3f.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><i class="anzhiyufont anzhiyu-icon-circle-dot" title="朗读摘要"></i><div id="ai-tag">小嗷犬 GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己 🙈</div><div class="ai-btn-item">生成本文简介 👋</div><div class="ai-btn-item">推荐相关文章 📖</div><div class="ai-btn-item">前往主页 🏠</div><div class="ai-btn-item" id="go-tianli-blog">前往爱发电购买</div></div><script data-pjax src="/js/anzhiyu/ai_abstract.js"></script></div><article class="post-content" id="article-container" itemscope itemtype="https://blog.marquis.eu.org/posts/ee738371/"><header><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" tabindex="-1" itemprop="url">数据分析</a><a href="/tags/Python/" tabindex="-1" itemprop="url">Python</a><h1 id="CrawlerTitle" itemprop="name headline">Python 数据处理：NumPy库的使用</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小嗷犬</span><time itemprop="dateCreated datePublished" datetime="2022-08-26T13:33:00.000Z" title="发表于 2022-08-26 21:33:00">2022-08-26</time><time itemprop="dateCreated datePublished" datetime="2023-10-07T13:00:34.000Z" title="更新于 2023-10-07 21:00:34">2023-10-07</time></header><h2 id="NumPy简介">NumPy简介</h2><p><strong>NumPy</strong>（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。</p><p><strong>NumPy的部分功能如下:</strong></p><ul><li><code>ndarray</code>，一个具有矢量算术运算和复杂<strong>广播</strong>能力的快速且节省空间的<em><strong>多维数组</strong></em>。</li><li>用于对<strong>整组数据</strong>进行快速运算的标准数学函数（无需编写循环）。</li><li>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。</li><li>线性代数、随机数生成以及傅里叶变换功能。</li><li>用于集成由C、C++、Fortran等语言编写的代码的API。</li></ul><p>NumPy对于数值计算特别重要的原因之一，是因为它可以<strong>高效处理大数组的数据</strong>。这是因为：</p><ul><li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li><li>NumPy可以在整个数组上执行复杂的计算，而<strong>不需要Python的for循环</strong>。</li></ul><p>在<code>jupyter notebook</code>中运行以下代码，可以比较NumPy数组和Python列表的数据运算效率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 考察一个包含一百万整数的数组，和一个等价的Python列表：</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>my_arr = np.arange(<span class="hljs-number">1000000</span>)<br>my_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>))<br><span class="hljs-comment"># 各个序列分别乘以2：</span><br>%time <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>): my_arr2 = my_arr * <span class="hljs-number">2</span><br>%time <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>): my_list2 = [x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> my_list]<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>CPU time：衡量的是CPU用来执行程序的时间；</li><li>Wall time：从计算开始到计算结束等待的时间。</li></ul><hr><h2 id="NumPy的ndarray：一种多维数组对象">NumPy的ndarray：一种多维数组对象</h2><p>NumPy最重要的一个特点就是其N维数组对象（即<code>ndarray</code>），该对象是一个快速而灵活的大数据集容器。你可以利用这种数组对整块数据执行一些数学运算，其语法跟<strong>标量元素</strong>之间的运算一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(data)<br><span class="hljs-built_in">print</span>(data * <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(data + data)<br></code></pre></td></tr></table></figure><p>对于Python原生的列表，这些乘法和加法的规则有点不一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pythonList = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(pythonList * <span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(pythonList + pythonList)<br></code></pre></td></tr></table></figure><p><code>ndarray</code>是一个通用的同构数据多维容器，也就是说，<strong>其中的所有元素必须是相同类型的</strong>（记录数组除外）。每个数组都有一个<code>shape</code>（一个表示各维度大小的元组）和一个<code>dtype</code>（一个用于说明数组数据类型的对象）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(data)<br><span class="hljs-built_in">print</span>(data.shape)<br><span class="hljs-built_in">print</span>(data.dtype)<br></code></pre></td></tr></table></figure><h3 id="创建ndarray">创建ndarray</h3><p>创建数组最简单的办法就是使用<code>array</code>函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5.0</span>,<span class="hljs-number">6</span>]<br>arr1 = np.array(data1)<br><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(arr1.ndim)<br><span class="hljs-built_in">print</span>(arr1.shape)<br><span class="hljs-built_in">print</span>(arr1.dtype)<br></code></pre></td></tr></table></figure><p>嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data2 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6.1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]<br>arr2 = np.array(data2)<br><span class="hljs-built_in">print</span>(arr2)<br><span class="hljs-built_in">print</span>(arr2.ndim)<br><span class="hljs-built_in">print</span>(arr2.shape)<br><span class="hljs-built_in">print</span>(arr2.dtype)<br></code></pre></td></tr></table></figure><p>除<code>np.array</code>之外，还有一些函数也可以新建数组。比如，<code>zeros</code>和<code>ones</code>分别可以创建指定长度或形状的全0或全1数组。<code>empty</code>可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-built_in">print</span>(np.zeros(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">6</span>)))<br><span class="hljs-built_in">print</span>(np.empty((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)))<br></code></pre></td></tr></table></figure><p><code>arange</code>是Python内置函数range的数组版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>dataArange = np.arange(<span class="hljs-number">15</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(dataArange))<br><span class="hljs-built_in">print</span>(dataArange)<br></code></pre></td></tr></table></figure><p>下表列出了一些数组创建函数。由于NumPy关注的是数值计算，因此，如果没有特别指定，数据类型基本都是<code>float64</code>（浮点数）。</p><table><thead><tr><th>函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>array</td><td style="text-align:left">将输入数据（列表、元组、数组或其它序列类型)转换为ndarray。要么推断出dtype，要么特别指定dtype。默认直接复制输入数据</td></tr><tr><td>asarray</td><td style="text-align:left">将输入转换为ndarray，如果输入本身就是一个ndarray就不进行复制</td></tr><tr><td>arange</td><td style="text-align:left">类似于内置的range，但返回的是一个ndarray而不是列表</td></tr><tr><td>ones,ones_like</td><td style="text-align:left">根据指定的形状和dtype创建一个全1数组。one_like 以另一个数组为参数，并根据其形状和dtype创建一个全1数组</td></tr><tr><td>zeros,zeros_like</td><td style="text-align:left">类似于ones和ones_like，只不过产生的是全О数组而已</td></tr><tr><td>empty,empty_like</td><td style="text-align:left">创建新数组，只分配内存空间但不填充任何值</td></tr><tr><td>full,full_like</td><td style="text-align:left">用fill value中的所有值,根据指定的形状和dtype创建一个数组。full_like使用另一个数组,用相同的形状和dtype创建</td></tr><tr><td>eye,identity</td><td style="text-align:left">创建一个正方的N×N单位矩阵（对角线为1，其余为0）</td></tr></tbody></table><hr><h3 id="ndarray的数据类型">ndarray的数据类型</h3><p><code>dtype</code>（数据类型）是一个特殊的对象，它含有<code>ndarray</code>将一块内存解释为特定数据类型所需的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr1 = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], dtype=np.float64)<br>arr2 = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], dtype=np.int32)<br><span class="hljs-built_in">print</span>(arr1.dtype)<br><span class="hljs-built_in">print</span>(arr1)<br><span class="hljs-built_in">print</span>(arr2.dtype)<br><span class="hljs-built_in">print</span>(arr2)<br></code></pre></td></tr></table></figure><p>数值型<code>dtype</code>的命名方式相同：一个类型名（如 float 或 int ），后面跟一个用于表示各元素位长的数字。标准的双精度浮点值（即Python中的 float 对象）需要占用8字节（即64位）。因此，该类型在NumPy中就记作<code>float64</code>。</p><p>下表列出了NumPy所支持的全部数据类型：</p><table><thead><tr><th>类型</th><th>类型代码</th><th>描述</th></tr></thead><tbody><tr><td>int8、 uint8</td><td>i1、 u1</td><td>有符号和无符号的8位（1个字节)整型</td></tr><tr><td>int16、uint16</td><td>i2、u2</td><td>有符号和无符号的16位 （2个字节)整型</td></tr><tr><td>int32、uint32</td><td>i4、u4</td><td>有符号和无符号的32位 （4个字节）整型</td></tr><tr><td>int64、 uint64</td><td>i8、u8</td><td>有符号和无符号的64位(8个字节)整型</td></tr><tr><td>float16</td><td>f2</td><td>半精度浮点数</td></tr><tr><td>float32</td><td>f4或f</td><td>标准的单精度浮点数。与C的float兼容</td></tr><tr><td>float64</td><td>f8或d</td><td>标准的双精度浮点数。与C的double和Python的float对象兼容</td></tr><tr><td>float128</td><td>f16或g</td><td>扩展精度浮点数</td></tr><tr><td>complex64、complex128、 complex256</td><td>c8、c16、c32</td><td>分别用两个32位、64位或128位浮点数表示的复数</td></tr><tr><td>bool</td><td>?</td><td>存储True和False值的布尔类型</td></tr><tr><td>object</td><td>O</td><td>Python对象类型</td></tr><tr><td>string_</td><td>S</td><td>固定长度的字符串类型(每个字符1个字节)。例如，要创建一个长度为10的字符串，应使用S10</td></tr><tr><td>unicode_</td><td>U</td><td>固定长度的unicode类型（字节数由平台决定)。跟字符串的定义方式一样（如U10)</td></tr></tbody></table><p>可以通过<code>ndarray</code>的<code>astype</code>方法明确地将一个数组从一个<code>dtype</code>转换成另一个<code>dtype</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span>(arr.dtype)<br><span class="hljs-built_in">print</span>(arr)<br>float_arr = arr.astype(np.float64)<br><span class="hljs-built_in">print</span>(float_arr.dtype)<br><span class="hljs-built_in">print</span>(float_arr)<br></code></pre></td></tr></table></figure><p>如果将浮点数转换成整数，则小数部分将会被截取删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.array([<span class="hljs-number">3.7</span>, -<span class="hljs-number">1.2</span>, -<span class="hljs-number">2.6</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">12.9</span>, <span class="hljs-number">10.1</span>])<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.astype(np.int32))<br></code></pre></td></tr></table></figure><p>如果某字符串数组表示的全是数字，也可以用<code>astype</code>将其转换为数值形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>numeric_strings = np.array([<span class="hljs-string">&#x27;1.25&#x27;</span>, <span class="hljs-string">&#x27;-9.6&#x27;</span>, <span class="hljs-string">&#x27;42&#x27;</span>], dtype=np.string_)<br><span class="hljs-built_in">print</span>(numeric_strings)<br><span class="hljs-built_in">print</span>(numeric_strings.astype(np.float64))<br></code></pre></td></tr></table></figure><hr><h3 id="NumPy数组的运算">NumPy数组的运算</h3><p>数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化（vectorization）。大小相等的数组之间的任何算术运算都会将运算应用到<strong>元素级</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.array([[<span class="hljs-number">1.</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr * arr)<br><span class="hljs-built_in">print</span>(arr - arr)<br></code></pre></td></tr></table></figure><p>数组与标量的算术运算会将标量值传播到各个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.array([[<span class="hljs-number">1.</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> / arr)<br><span class="hljs-built_in">print</span>(arr ** <span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><p><strong>大小相同的数组之间的比较会生成布尔值数组：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>arr = np.array([[<span class="hljs-number">1.</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(arr)<br><br>arr2 = np.array([[<span class="hljs-number">0.</span>, <span class="hljs-number">4</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">12</span>]])<br><span class="hljs-built_in">print</span>(arr2)<br><br><span class="hljs-built_in">print</span>(arr  arr2)<br></code></pre></td></tr></table></figure><h3 id="基本的索引和切片">基本的索引和切片</h3><p>NumPy数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式有很多。一维数组很简单。从表面上看，它们跟Python列表的功能差不多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">10</span>) * <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr[<span class="hljs-number">5</span>])<br><br>arr_tmp = arr[<span class="hljs-number">5</span>:<span class="hljs-number">8</span>]<br><span class="hljs-built_in">print</span>(arr_tmp)<br><br>arr_tmp[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(arr_tmp)<br></code></pre></td></tr></table></figure><p>跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的<strong>任何修改都会直接反映到源数组上</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">10</span>) * <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-comment"># 先创建一个arr的切片：</span><br>arr_slice = arr[<span class="hljs-number">5</span>:<span class="hljs-number">8</span>]<br><span class="hljs-built_in">print</span>(arr_slice)<br><br><span class="hljs-comment"># 现在，当修改arr_slice中的值，变动也会体现在原始数组arr中：</span><br>arr_slice[<span class="hljs-number">1</span>] = <span class="hljs-number">108</span><br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-comment"># 切片[ : ]会给数组中的所有值赋值：</span><br>arr_slice[:] = <span class="hljs-number">64</span><br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-comment"># 再来试试List</span><br>lst = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(lst)<br><br>lst_slice = lst[<span class="hljs-number">5</span>:<span class="hljs-number">8</span>]<br><span class="hljs-built_in">print</span>(lst_slice)<br><br>lst_slice[<span class="hljs-number">1</span>] = <span class="hljs-number">12345</span><br><span class="hljs-built_in">print</span>(lst_slice)<br><span class="hljs-built_in">print</span>(lst)<br></code></pre></td></tr></table></figure><p>如果你想要得到的是<code>ndarray</code>切片的一份副本而非视图，就需要明确地进行复制操作，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">10</span>) * <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(arr)<br><br>arr_slice = arr[<span class="hljs-number">5</span>:<span class="hljs-number">8</span>].copy()<br><span class="hljs-built_in">print</span>(arr_slice)<br><br>arr_slice[<span class="hljs-number">1</span>] = <span class="hljs-number">108</span><br><span class="hljs-built_in">print</span>(arr_slice)<br><span class="hljs-built_in">print</span>(arr)<br></code></pre></td></tr></table></figure><p>对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr2d = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(arr2d[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>因此，可以对各个元素进行递归访问，但这样需要做的事情有点多。你可以传入一个以逗号隔开的索引列表来选取单个元素。也就是说，下面两种方式是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr2d = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])<br><br><span class="hljs-built_in">print</span>(arr2d[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(arr2d[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>二维数组的索引方式，轴0作为行，轴1作为列：<br><img src="/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" data-lazy-src="https://img-blog.csdnimg.cn/e9a7dfdd666a4db6afa699578eb52128.png" alt="二维数组"></p><p>在多维数组中，如果省略了后面的索引，则返回对象会是一个维度低一点的<code>ndarray</code>（它含有高一级维度上的所有数据）。因此，在2×2×3数组<code>arr3d</code>中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr3d = np.array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], <br>                  [[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]]])<br><span class="hljs-built_in">print</span>(arr3d)<br><span class="hljs-built_in">print</span>(arr3d[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>标量值和数组都可以被赋值给<code>arr3d[0]</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr3d = np.array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]], <br>                  [[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]]])<br><br>old_values = arr3d[<span class="hljs-number">0</span>].copy()<br><br>arr3d[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span><br><span class="hljs-built_in">print</span>(arr3d)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n&#x27;</span> + <span class="hljs-string">&#x27;-&#x27;</span>*<span class="hljs-number">20</span> + <span class="hljs-string">&#x27;\n&#x27;</span>)<br><br>arr3d[<span class="hljs-number">0</span>] = old_values<br><span class="hljs-built_in">print</span>(arr3d)<br></code></pre></td></tr></table></figure><hr><h3 id="切片索引">切片索引</h3><p><code>ndarray</code>的切片语法跟Python列表这样的一维对象差不多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">10</span>) * <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>])<br></code></pre></td></tr></table></figure><p>对于之前的二维数组<code>arr2d</code>，其切片方式稍显不同，它是沿着第0轴（即第一个轴）切片的。也就是说，切片是沿着一个轴向选取元素的。表达式<code>arr2d[:2]</code>可以被认为是“选取<code>arr2d</code>的前两行”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr2d = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(arr2d)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(arr2d[:<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>可以一次传入多个切片，就像传入多个索引那样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr2d = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(arr2d)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(arr2d[<span class="hljs-number">1</span>:, <span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><p>像这样进行切片时，只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度的切片。</p><p>例如，可以选取第二行的前两列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr2d = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(arr2d)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(arr2d[<span class="hljs-number">1</span>, :<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>相似的，还可以选择第三列的前两行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr2d = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(arr2d)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(arr2d[:<span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>“只有冒号”表示选取整个轴，因此你可以像下面这样只对高维轴进行切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr2d = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(arr2d)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(arr2d[:,:<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>对切片表达式的赋值操作也会被扩散到整个选区：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr2d = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(arr2d)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br>arr2d[:<span class="hljs-number">2</span>, <span class="hljs-number">1</span>:] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(arr2d)<br></code></pre></td></tr></table></figure><p><img src="/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" data-lazy-src="https://img-blog.csdnimg.cn/929b842309634ef88cdf1fe785df2147.png" alt="索引与切片"></p><hr><h3 id="布尔型索引">布尔型索引</h3><p>来看这样一个例子，假设我们有一个用于存储数据的数组以及一个存储姓名的数组（含有重复项）。在这里，我将使用<code>numpy.random</code>中的<code>randn</code>函数生成一些正态分布的随机数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>names = np.array([<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <br>                  <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>])<br>data = np.random.randn(<span class="hljs-number">7</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(names)<br><span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><p>假设每个名字都对应<code>data</code>数组中的一行，而我们想要选出对应于名字<code>&quot;Bob&quot;</code>的所有行。跟算术运算一样，数组的比较运算（如<code>==</code>）也是矢量化的。因此，对<code>names</code>和字符串<code>&quot;Bob&quot;</code>的比较运算将会产生一个布尔型数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>names = np.array([<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <br>                  <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>])<br><span class="hljs-built_in">print</span>(names == <span class="hljs-string">&#x27;Bob&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这个布尔型数组可用于数组索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>names = np.array([<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <br>                  <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>])<br>data = np.random.randn(<span class="hljs-number">7</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-built_in">print</span>(data[names == <span class="hljs-string">&#x27;Bob&#x27;</span>])<br></code></pre></td></tr></table></figure><p>布尔型数组的长度必须跟被索引的轴长度一致。此外，还可以将布尔型数组跟切片、整数混合使用。</p><p>下面的例子，选取了<code>names == 'Bob'</code>的行，并索引了列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>names = np.array([<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <br>                  <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>])<br>data = np.random.randn(<span class="hljs-number">7</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-built_in">print</span>(data[names == <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">2</span>:])<br><span class="hljs-built_in">print</span>(data[names == <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>要选择除<code>&quot;Bob&quot;</code>以外的其他值，既可以使用不等于符号（<code>!=</code>），也可以通过<code>~</code>对条件进行否定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>names = np.array([<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <br>                  <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>])<br>data = np.random.randn(<span class="hljs-number">7</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-built_in">print</span>(names != <span class="hljs-string">&#x27;Bob&#x27;</span>)<br><span class="hljs-built_in">print</span>(data[~(names == <span class="hljs-string">&#x27;Bob&#x27;</span>)])<br></code></pre></td></tr></table></figure><p>选取这三个名字中的两个需要组合应用多个布尔条件，使用<code>&amp;</code>（与）、<code>|</code>（或）之类的布尔算术运算符即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>names = np.array([<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <br>                  <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>])<br>data = np.random.randn(<span class="hljs-number">7</span>,<span class="hljs-number">4</span>)<br><br>mask = (names == <span class="hljs-string">&#x27;Bob&#x27;</span>) | (names == <span class="hljs-string">&#x27;Will&#x27;</span>)<br><span class="hljs-built_in">print</span>(mask)<br><span class="hljs-built_in">print</span>(data[mask])<br></code></pre></td></tr></table></figure><p>通过布尔型数组设置值是一种经常用到的手段。为了将<code>data</code>中的所有负值都设置为0，我们只需：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>names = np.array([<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <br>                  <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>])<br>data = np.random.randn(<span class="hljs-number">7</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-built_in">print</span>(data)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br>data[data &lt; <span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><p>通过一维布尔数组设置整行或列的值也很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>names = np.array([<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>, <br>                  <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>])<br>data = np.random.randn(<span class="hljs-number">7</span>,<span class="hljs-number">4</span>)<br><br><span class="hljs-built_in">print</span>(data)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br>data[names != <span class="hljs-string">&#x27;Joe&#x27;</span>] = <span class="hljs-number">7</span><br><span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><hr><h3 id="花式索引">花式索引</h3><p>花式索引（Fancy indexing）是一个NumPy术语，它指的是利用整数数组进行索引。假设我们有一个8×4数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.empty((<span class="hljs-number">8</span>, <span class="hljs-number">4</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    arr[i] = i<br><span class="hljs-built_in">print</span>(arr)<br><br>arr[:<span class="hljs-number">2</span>] = arr[[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]]<br><span class="hljs-built_in">print</span>(arr)<br></code></pre></td></tr></table></figure><p>为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或<code>ndarray</code>即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.empty((<span class="hljs-number">8</span>, <span class="hljs-number">4</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    arr[i] = i<br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br><span class="hljs-built_in">print</span>(arr[[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>]])<br></code></pre></td></tr></table></figure><p>使用负数索引将会从末尾开始选取行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.empty((<span class="hljs-number">8</span>, <span class="hljs-number">4</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    arr[i] = i<br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br><span class="hljs-built_in">print</span>(arr[[-<span class="hljs-number">3</span>, -<span class="hljs-number">5</span>, -<span class="hljs-number">7</span>]])<br></code></pre></td></tr></table></figure><p>一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">32</span>).reshape(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br><span class="hljs-built_in">print</span>(arr[[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]])<br></code></pre></td></tr></table></figure><p>最终选出的是元素(1,0)、(5,3)、(7,1)和(2,2)。无论数组是多少维的，花式索引总是一维的。</p><p>这个花式索引的行为可能会跟某些用户的预期不一样，选取矩阵的行列子集应该是矩形区域的形式才对。下面是得到该结果的一个办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">32</span>).reshape(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br><span class="hljs-built_in">print</span>(arr[[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>]][:, [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])<br></code></pre></td></tr></table></figure><p>记住，花式索引跟切片不一样，它总是将数据复制到新数组中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">32</span>).reshape(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br>arrNew = arr[[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>]][:, [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]<br><span class="hljs-built_in">print</span>(arrNew)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br>arrNew[<span class="hljs-number">1</span>] = -<span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(arrNew)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br><span class="hljs-built_in">print</span>(arr)<br></code></pre></td></tr></table></figure><hr><h3 id="数组转置和轴对换">数组转置和轴对换</h3><p>转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有<code>transpose</code>方法，还有一个特殊的<code>T</code>属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">3</span>,<span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br><span class="hljs-built_in">print</span>(arr.T)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br><span class="hljs-built_in">print</span>(arr.transpose((<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)))<br></code></pre></td></tr></table></figure><p>在进行矩阵计算时，经常需要用到该操作，比如利用<code>np.dot</code>计算矩阵内积：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">6</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br><span class="hljs-built_in">print</span>(np.dot(arr.T, arr))<br></code></pre></td></tr></table></figure><p>简单的转置可以使用<code>.T</code>，它其实就是进行轴对换而已。<code>ndarray</code>还有一个<code>swapaxes</code>方法，它需要接受一对轴编号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">16</span>).reshape((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><br>arr = arr.swapaxes(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(arr)<br></code></pre></td></tr></table></figure><hr><h2 id="通用函数：快速的元素级数组函数">通用函数：快速的元素级数组函数</h2><p>通用函数（即<code>ufunc</code>）是一种对<code>ndarray</code>中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。</p><p>许多<code>ufunc</code>都是简单的元素级变体，如<code>sqrt</code>和<code>exp</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(np.sqrt(arr))<br><span class="hljs-built_in">print</span>(np.exp(arr))<br></code></pre></td></tr></table></figure><p>这些都是<strong>一元（unary）ufunc</strong>。另外一些（如<code>add</code>或<code>maximum</code>）接受2个数组（因此也叫<strong>二元（binary）ufunc</strong>），并返回一个结果数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.random.randn(<span class="hljs-number">8</span>)<br>y = np.random.randn(<span class="hljs-number">8</span>)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(np.maximum(x, y))<br></code></pre></td></tr></table></figure><p>有些<code>ufunc</code>可以返回多个数组。<code>modf</code>就是一个例子，它是Python内置函数<code>divmod</code>的矢量化版本，它会返回浮点数数组的小数和整数部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">7</span>) * <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">50</span>)<br>remainder, whole_part = np.modf(arr)<br><span class="hljs-built_in">print</span>(remainder)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">50</span>)<br><span class="hljs-built_in">print</span>(whole_part)<br></code></pre></td></tr></table></figure><p><code>ufuncs</code>可以接受一个<code>out</code>可选参数，这样就能在数组原地进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">50</span>)<br><span class="hljs-built_in">print</span>(np.sqrt(arr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">50</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">50</span>)<br>arr = arr.astype(np.float64)<br>np.sqrt(arr,arr)<br><span class="hljs-built_in">print</span>(arr)<br></code></pre></td></tr></table></figure><p>下表列出了一些<strong>一元和二元ufunc</strong>：</p><table><thead><tr><th>一元ufunc</th><th>描述</th></tr></thead><tbody><tr><td>abs、 fabs</td><td>计算整数、浮点数或复数的绝对值。对于非复数值，可以使用更快的fabs</td></tr><tr><td>sqrt</td><td>计算各元素的平方根。相当于arr** 0.5</td></tr><tr><td>square</td><td>计算各元素的平方。相当于arr**2</td></tr><tr><td>exp</td><td>计算各元素的指数e<sup>x</sup></td></tr><tr><td>log、log10、log2、log1p</td><td>分别为自然对数（底数为e)、底数为10的log、底数为2的log、log(1 +x)</td></tr><tr><td>sign</td><td>计算各元素的正负号:1(正数)、0(零)、-1(负数)</td></tr><tr><td>ceil</td><td>计算各元素的ceiling值，即大于等于该值的最小整数</td></tr><tr><td>floor</td><td>计算各元素的floor值，即小于等于该值的最大整数</td></tr><tr><td>arccos、arccosh、arcsin、arcsinh、arctan、arctanh</td><td>反三角函数</td></tr><tr><td>logical_not</td><td>计算各元素not x的真值。相当于-arr</td></tr></tbody></table><table><thead><tr><th>二元ufunc</th><th>描述</th></tr></thead><tbody><tr><td>add</td><td>将数组中对应的元素相加</td></tr><tr><td>subtract</td><td>从第一个数组中减去第二个数组中的元素</td></tr><tr><td>multiply</td><td>数组元素相乘</td></tr><tr><td>divide、floor_divide</td><td>除法或向下圆整除法（丢弃余数)</td></tr><tr><td>power</td><td>对第一个数组中的元素A，根据第二个数组中的相应元素B，计算AB</td></tr><tr><td>maximum、fmax</td><td>元素级的最大值计算。fmax将忽略NaN</td></tr><tr><td>minimum、fmin</td><td>元素级的最小值计算。fmin将忽略NaN</td></tr><tr><td>mod</td><td>元素级的求模计算（除法的余数)</td></tr><tr><td>copysign</td><td>将第二个数组中的值的符号复制给第一个数组中的值</td></tr></tbody></table><hr><h3 id="指定输出">指定输出</h3><p>在进行大量运算时， 指定一个用于存放运算结果的数组时非常有用的。不同于创建临时数组，可以用这个特性将计算结果直接写入到期望的存储位置，这样在进行较大数据运算时，可以有效节约内存。所有的通用函数都可以通过<code>out</code>参数来指定计算结果的存放位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.arange(<span class="hljs-number">5</span>)<br>y = np.empty(<span class="hljs-number">5</span>)<br>np.multiply(x, <span class="hljs-number">10</span>, out = y)<br><span class="hljs-built_in">print</span>(y)<br></code></pre></td></tr></table></figure><p>这个特性也可以被用作数组视图，例如可以将计算结果写入指定数组的每隔一个元素的位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.arange(<span class="hljs-number">5</span>)<br>y = np.zeros(<span class="hljs-number">10</span>)<br>np.power(<span class="hljs-number">2</span>, x, out = y[::<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(y)<br></code></pre></td></tr></table></figure><hr><h3 id="聚合">聚合</h3><p>可以使用任何通用函数的<code>reduce</code>方法，该方法会对给定的元素和操作重复执行，直至得到单个的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(np.add.reduce(x))<br><span class="hljs-built_in">print</span>(np.multiply.reduce(x))<br></code></pre></td></tr></table></figure><p>类似的还有<code>accumulate</code>，可以存储每次计算的中间结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(np.add.accumulate(x))<br><span class="hljs-built_in">print</span>(np.multiply.accumulate(x))<br></code></pre></td></tr></table></figure><hr><h3 id="外积">外积</h3><p>任何通用函数都可以用<code>outer</code>方法获得两个不同输入数组所有元素对的函数运算结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(np.multiply.outer(x, x))<br></code></pre></td></tr></table></figure><hr><h2 id="利用数组进行数据处理">利用数组进行数据处理</h2><p>假设我们想要在一组值（网格型）上计算函数&lt;font。 color=bluesqrt(x<sup>2</sup>+y<sup>2</sup>)&lt;/font。<code>np.meshgrid</code>函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的<code>(x,y)</code>对）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>points = np.arange(<span class="hljs-number">5</span>) <br><span class="hljs-built_in">print</span>(points)<br><br>xs, ys = np.meshgrid(points, points)<br><span class="hljs-built_in">print</span>(xs)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(ys)<br></code></pre></td></tr></table></figure><p>现在，对该函数的求值运算就好办了，把这两个数组当做两个浮点数那样编写表达式即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>points = np.arange(<span class="hljs-number">5</span>) <br><span class="hljs-built_in">print</span>(points)<br><br>xs, ys = np.meshgrid(points, points)<br><span class="hljs-built_in">print</span>(xs)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(ys)<br><br>z = np.sqrt(xs ** <span class="hljs-number">2</span> + ys **<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(z)<br></code></pre></td></tr></table></figure><hr><h3 id="将条件逻辑表述为数组运算">将条件逻辑表述为数组运算</h3><p><code>numpy.where</code>函数是三元表达式<code>x if condition else y</code>的矢量化版本。假设我们有一个布尔数组和两个值数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">xarr = np.array([<span class="hljs-number">1.1</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">1.4</span>, <span class="hljs-number">1.5</span>])<br>yarr = np.array([<span class="hljs-number">2.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">2.3</span>, <span class="hljs-number">2.4</span>, <span class="hljs-number">2.5</span>])<br>cond = np.array([<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>])<br></code></pre></td></tr></table></figure><p>假设我们想要根据<code>cond</code>中的值选取<code>xarr</code>和<code>yarr</code>的值：当<code>cond</code>中的值为<code>True</code>时，选取<code>xarr</code>的值，否则从<code>yarr</code>中选取。列表推导式的写法应该如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">result = [(x <span class="hljs-keyword">if</span> c <span class="hljs-keyword">else</span> y) <span class="hljs-keyword">for</span> x, y, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(xarr, yarr, cond)]<br></code></pre></td></tr></table></figure><p>若使用<code>np.where</code>，则可以将该功能写得非常简洁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.where(cond, xarr, yarr)<br></code></pre></td></tr></table></figure><p>在数据分析工作中，<code>where</code>通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用<code>np.where</code>，则会非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(np.where(arr0, <span class="hljs-number">2</span>, -<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>使用<code>np.where</code>，可以将标量和数组结合起来。例如，可用常数2替换<code>arr</code>中所有正的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(np.where(arr  <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, arr))<br></code></pre></td></tr></table></figure><p>去除异常值，例如，在成绩列表中，将所有小于0的成绩改为0，所有大于100的成绩改为100：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>scoreArr = np.array([<span class="hljs-number">88</span>, <span class="hljs-number">90</span>, <span class="hljs-number">58</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">91</span>, <span class="hljs-number">108</span>])<br>scoreArr = np.where(scoreArr  <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, scoreArr)<br><span class="hljs-built_in">print</span>(scoreArr)<br>scoreArr = np.where(scoreArr &lt; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, scoreArr)<br><span class="hljs-built_in">print</span>(scoreArr)<br></code></pre></td></tr></table></figure><hr><h3 id="数学和统计方法">数学和统计方法</h3><p>可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。<code>sum</code>、<code>mean</code>以及标准差<code>std</code>等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.mean())<br><span class="hljs-built_in">print</span>(np.mean(arr))<br><span class="hljs-built_in">print</span>(arr.<span class="hljs-built_in">sum</span>())<br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(arr))<br></code></pre></td></tr></table></figure><p><code>mean</code>和<code>sum</code>这类的函数可以接受一个<code>axis</code>选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.mean(axis=<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(arr.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>这里，<code>arr.mean(1)</code>是“计算行的平均值”，<code>arr.sum(0)</code>是“计算每列的和”。</p><p><code>axis</code>关键字指定的时数组将会被<strong>折叠</strong>的维度，而不是将要返回的维度。因此，指定<code>axis=0</code>意味着第0个轴将要被折叠，对于二维数组来说，这意味着每一列的值都将被聚合。</p><p>其他如<code>cumsum</code>和<code>cumprod</code>之类的方法则不聚合，而是产生一个由中间结果组成的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.array([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>])<br><span class="hljs-built_in">print</span>(arr.cumsum())<br></code></pre></td></tr></table></figure><p>在多维数组中，累加函数（如<code>cumsum</code>）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.cumsum(axis=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(arr.cumprod(axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>下表列出了全部的基本数组统计方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>sum</td><td>对数组中全部或某轴向的元素求和。零长度的数组的sum为0</td></tr><tr><td>mean</td><td>算术平均数。零长度的数组的mean为NaN</td></tr><tr><td>std、 var</td><td>分别为标准差和方差，自由度可调（默认为n)</td></tr><tr><td>min、 max</td><td>最大值和最小值</td></tr><tr><td>argmin、argmax</td><td>分别为最大和最小元素的索引</td></tr><tr><td>cumsum</td><td>所有元素的累计和</td></tr><tr><td>cumprod</td><td>所有元素的累计积</td></tr></tbody></table><hr><h3 id="用于布尔型数组的方法">用于布尔型数组的方法</h3><p>在上面这些方法中，布尔值会被强制转换为1（<code>True</code>）和0（<code>False</code>）。因此，<code>sum</code>经常被用来对布尔型数组中的<code>True</code>值计数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>((arr  <span class="hljs-number">0</span>).<span class="hljs-built_in">sum</span>())<br></code></pre></td></tr></table></figure><p>另外还有两个方法<code>any</code>和<code>all</code>，它们对布尔型数组非常有用。<code>any</code>用于测试数组中是否存在一个或多个<code>True</code>，而<code>all</code>则检查数组中所有值是否都是<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>bools = np.array([<span class="hljs-literal">False</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>])<br><span class="hljs-built_in">print</span>(bools.<span class="hljs-built_in">any</span>())<br><span class="hljs-built_in">print</span>(bools.<span class="hljs-built_in">all</span>())<br></code></pre></td></tr></table></figure><hr><h3 id="排序">排序</h3><p>跟Python内置的列表类型一样，NumPy数组也可以通过<code>sort</code>方法<strong>就地排序</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(arr)<br>arr.sort()<br><span class="hljs-built_in">print</span>(arr)<br></code></pre></td></tr></table></figure><p>多维数组可以在任何一个轴向上进行排序，只需将轴编号传给<code>sort</code>即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(arr)<br>arr.sort(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(arr)<br></code></pre></td></tr></table></figure><p>顶级方法<code>np.sort</code>返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>large_arr = np.random.randn(<span class="hljs-number">1000</span>)<br>large_arr.sort()<br><span class="hljs-built_in">print</span>(large_arr[<span class="hljs-built_in">int</span>(<span class="hljs-number">0.05</span> * <span class="hljs-built_in">len</span>(large_arr))])<br></code></pre></td></tr></table></figure><hr><h3 id="唯一化以及其它的集合逻辑">唯一化以及其它的集合逻辑</h3><p>NumPy提供了一些针对一维<code>ndarray</code>的基本集合运算。最常用的可能要数<code>np.unique</code>了，它用于找出数组中的唯一值并返回已排序的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>names = np.array([<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>                  <span class="hljs-string">&#x27;Will&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>, <span class="hljs-string">&#x27;Joe&#x27;</span>])<br><span class="hljs-built_in">print</span>(np.unique(names))<br><br>ints = np.array([<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(np.unique(ints))<br></code></pre></td></tr></table></figure><p><code>np.in1d</code>用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>values = np.array([<span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><span class="hljs-built_in">print</span>(np.in1d(values, [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]))<br></code></pre></td></tr></table></figure><p>下表列出了NumPy中的集合函数：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>unique(x)</td><td>计算x中的唯一元素，并返回有序结果</td></tr><tr><td>intersect1d(x, y)</td><td>计算x和y中的公共元素，并返回有序结果</td></tr><tr><td>union1d(x, y)</td><td>计算x和y的并集，并返回有序结果</td></tr><tr><td>in1d(x, y)</td><td>得到一个表示“x的元素是否包含于y”的布尔型数组</td></tr><tr><td>setdiff1d(x, y)</td><td>集合的差，即元素在x中且不在y中</td></tr><tr><td>setxor1d(x, y)</td><td>集合的对称差，即存在于一个数组中但不同时存在于两个数组中的元素</td></tr></tbody></table><hr><h2 id="用于数组的文件输入输出">用于数组的文件输入输出</h2><p>NumPy能够读写磁盘上的文本数据或二进制数据。这一小节只讨论NumPy的内置二进制格式，因为更多的用户会使用pandas或其它工具加载文本或表格数据。</p><p><code>np.save</code>和<code>np.load</code>是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为<code>.npy</code>的文件中的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">10</span>)<br>np.save(<span class="hljs-string">&#x27;some_array&#x27;</span>, arr)<br><span class="hljs-built_in">print</span>(np.load(<span class="hljs-string">&#x27;some_array.npy&#x27;</span>))<br></code></pre></td></tr></table></figure><p>通过<code>np.savez</code>可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">10</span>)<br>np.savez(<span class="hljs-string">&#x27;array_archive.npz&#x27;</span>, a=arr, b=arr * <span class="hljs-number">2</span>)<br>arch = np.load(<span class="hljs-string">&#x27;array_archive.npz&#x27;</span>)<br><span class="hljs-built_in">print</span>(arch[<span class="hljs-string">&#x27;b&#x27;</span>])<br></code></pre></td></tr></table></figure><p>如果要将数据压缩，可以使用<code>numpy.savez_compressed</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.savez_compressed(<span class="hljs-string">&#x27;arrays_compressed.npz&#x27;</span>, a=arr, b=arr * <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><hr><h2 id="线性代数">线性代数</h2><p>线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。NumPy提供了一个用于矩阵乘法的<code>dot</code>函数（既是一个数组方法也是numpy命名空间中的一个函数）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.array([[<span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>], [<span class="hljs-number">4.</span>, <span class="hljs-number">5.</span>, <span class="hljs-number">6.</span>]])<br>y = np.array([[<span class="hljs-number">6.</span>, <span class="hljs-number">23.</span>], [-<span class="hljs-number">1</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">20</span>)<br><span class="hljs-built_in">print</span>(x.dot(y))<br><span class="hljs-comment"># x.dot(y)等价于np.dot(x, y)：</span><br><span class="hljs-built_in">print</span>(np.dot(x, y))<br></code></pre></td></tr></table></figure><p>一个二维数组跟一个大小合适的一维数组的矩阵点积运算之后将会得到一个一维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.array([[<span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>], [<span class="hljs-number">4.</span>, <span class="hljs-number">5.</span>, <span class="hljs-number">6.</span>]])<br><span class="hljs-built_in">print</span>(np.dot(x, np.ones(<span class="hljs-number">3</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">print</span>(np.ones(<span class="hljs-number">3</span>).shape))<br></code></pre></td></tr></table></figure><p><code>@</code>符也可以用作中缀运算符，进行矩阵乘法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.array([[<span class="hljs-number">1.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>], [<span class="hljs-number">4.</span>, <span class="hljs-number">5.</span>, <span class="hljs-number">6.</span>]])<br><span class="hljs-built_in">print</span>(x @ np.ones(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p><code>numpy.linalg</code>中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟MATLAB和R等语言所使用的是相同的行业标准线性代数库，如BLAS、LAPACK、Intel MKL（Math Kernel Library，可能有，取决于你的NumPy版本）等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> numpy.linalg <span class="hljs-keyword">import</span> inv, qr<br>X = np.random.randn(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<br>mat = X.T.dot(X)<br><span class="hljs-built_in">print</span>(inv(mat))<br><span class="hljs-built_in">print</span>(mat.dot(inv(mat)))<br>q, r = qr(mat)<br><span class="hljs-built_in">print</span>(r)<br></code></pre></td></tr></table></figure><p>下表列出了一些最常用的线性代数函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>diag</td><td>以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一维数组转换为方阵（非对角线元素为O)</td></tr><tr><td>dot</td><td>矩阵乘法</td></tr><tr><td>trace</td><td>计算对角线元素的和</td></tr><tr><td>det</td><td>计算矩阵行列式</td></tr><tr><td>eig</td><td>计算方阵的特征值和特征向量</td></tr><tr><td>inv</td><td>计算方阵的逆</td></tr><tr><td>pinv</td><td>计算矩阵的Moore-Penrose伪逆</td></tr><tr><td>qr</td><td>计算QR分解</td></tr><tr><td>svd</td><td>计算奇异值分解（SVD)</td></tr><tr><td>solve</td><td>解线性方程组AX = B，其中A为一个方阵</td></tr><tr><td>lstsq</td><td>计算AX = B的最小二乘解</td></tr></tbody></table><hr><h2 id="伪随机数生成">伪随机数生成</h2><p><code>numpy.random</code>模块对Python内置的<code>random</code>进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。例如，你可以用<code>normal</code>来得到一个标准正态分布的4×4样本数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>samples = np.random.normal(size=(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(samples)<br></code></pre></td></tr></table></figure><p>Python内置的<code>random</code>模块则只能一次生成一个样本值。从下面的测试结果中可以看出，如果需要产生大量样本值，<code>numpy.random</code>快了不止一个数量级：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> normalvariate<br>N = <span class="hljs-number">1000000</span><br>%timeit samples = [normalvariate(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N)]<br>%timeit np.random.normal(size=N)<br></code></pre></td></tr></table></figure><p>我们说这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。你可以用NumPy的<code>np.random.seed</code>更改随机数生成种子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.random.seed(<span class="hljs-number">1234</span>)<br><span class="hljs-built_in">print</span>(np.random.randn(<span class="hljs-number">10</span>))<br>np.random.seed(<span class="hljs-number">1234</span>)<br><span class="hljs-built_in">print</span>(np.random.randn(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(np.random.randn(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(np.random.randn(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p><code>numpy.random</code>的数据生成函数使用了全局的随机种子。要避免全局状态，你可以使用<code>numpy.random.RandomState</code>，创建一个与其它隔离的随机数生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>rng = np.random.RandomState(<span class="hljs-number">1234</span>)<br><span class="hljs-built_in">print</span>(rng.randn(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p>下表列出了<code>numpy.random</code>中的部分函数：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>seed</td><td>确定随机数生成器的种子</td></tr><tr><td>permutation</td><td>返回一个序列的随机排列或返回一个随机排列的范围</td></tr><tr><td>shuffle</td><td>对一个序列就地随机排列</td></tr><tr><td>rand</td><td>产生均匀分布的样本值</td></tr><tr><td>randint</td><td>从给定的上下限范围内随机选取整数</td></tr><tr><td>randn</td><td>产生正态分布（平均值为0，标准差为1）的样本值，类似于MATLAB接口</td></tr><tr><td>binomial</td><td>产生二项分布的样本值</td></tr><tr><td>normal</td><td>产生正态（高斯）分布的样本值</td></tr><tr><td>beta</td><td>产生Beta分布的样本值</td></tr><tr><td>chisquare</td><td>产生卡方分布的样本值</td></tr><tr><td>gamma</td><td>产生Gamma分布的样本值</td></tr><tr><td>uniform</td><td>产生在[0,1)中均匀分布的样本值</td></tr></tbody></table><hr><h2 id="高级数组操作">高级数组操作</h2><p>除花式索引、切片、布尔条件取子集等操作之外，数组的操作方式还有很多。虽然pandas中的高级函数可以处理数据分析工作中的许多重型任务，但有时你还是需要编写一些在现有库中找不到的数据算法。</p><h3 id="数组重塑">数组重塑</h3><p>多数情况下，你可以无需复制任何数据，就将数组从一个形状转换为另一个形状。只需向数组的实例方法<code>reshape</code>传入一个表示新形状的元组即可实现该目的。例如，假设有一个一维数组，我们希望将其重新排列为一个矩阵（结果见图）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">3</span>), order=<span class="hljs-string">&#x27;C&#x27;</span>))<br><span class="hljs-built_in">print</span>(arr.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">3</span>), order=<span class="hljs-string">&#x27;F&#x27;</span>))<br></code></pre></td></tr></table></figure><p><img src="/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" data-lazy-src="https://img-blog.csdnimg.cn/5e44290d7f834eb7af7c222fd0cb4c36.png" alt="数组重塑"><br>多维数组也能被重塑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(arr.reshape((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)).reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)))<br></code></pre></td></tr></table></figure><p>作为参数的形状的其中一维可以是－1，它表示该维度的大小由数据本身推断而来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">15</span>)<br><span class="hljs-built_in">print</span>(arr.reshape((<span class="hljs-number">5</span>,-<span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><p>与<code>reshape</code>将一维数组转换为多维数组的运算过程相反的运算通常称为扁平化（flattening）或散开（raveling），对应的函数为<code>flatten</code>和<code>ravel</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">5</span>, <span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.flatten())<br><span class="hljs-built_in">print</span>(arr.ravel())<br></code></pre></td></tr></table></figure><p>如果结果中的值与原始数组相同，<code>ravel</code>不会产生源数据的副本。<code>flatten</code>方法的行为类似于<code>ravel</code>，只不过它总是返回数据的副本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">15</span>).reshape((<span class="hljs-number">5</span>, <span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(arr.flatten())<br></code></pre></td></tr></table></figure><hr><h3 id="C和Fortran顺序">C和Fortran顺序</h3><p>NumPy允许你更为灵活地控制数据在内存中的布局。默认情况下，NumPy数组是按行优先顺序创建的。在空间方面，这就意味着，对于一个二维数组，每行中的数据项是被存放在相邻内存位置上的。另一种顺序是列优先顺序，它意味着每列中的数据项是被存放在相邻内存位置上的。</p><p>像<code>reshape</code>和<code>reval</code>这样的函数，都可以接受一个表示数组数据存放顺序的<code>order</code>参数。一般可以是’C’或’F’（还有’A’和’K’等不常用的选项，具体请参考NumPy的文档）。上一小节的图片对此进行了说明。</p><hr><h3 id="数组的合并和拆分">数组的合并和拆分</h3><p><code>numpy.concatenate</code>可以按指定轴将一个由数组组成的序列（如元组、列表等）连接到一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr1 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br>arr2 = np.array([[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])<br><span class="hljs-built_in">print</span>(np.concatenate([arr1, arr2], axis=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(np.concatenate([arr1, arr2], axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>对于常见的连接操作，NumPy提供了一些比较方便的方法（如<code>vstack</code>和<code>hstack</code>）。因此，上面的运算还可以表达为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr1 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br>arr2 = np.array([[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]])<br><span class="hljs-built_in">print</span>(np.vstack((arr1, arr2)))<br><span class="hljs-built_in">print</span>(np.hstack((arr1, arr2)))<br></code></pre></td></tr></table></figure><p>与此相反，<code>split</code>用于将一个数组沿指定轴拆分为多个数组，传入到<code>np.split</code>的值指示在哪个索引处分割数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(arr)<br>first, second, third = np.split(arr, [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(first)<br><span class="hljs-built_in">print</span>(second)<br><span class="hljs-built_in">print</span>(third)<br></code></pre></td></tr></table></figure><p>下表列出了所有关于数组连接和拆分的函数，其中有些是专门为了方便常见的连接运算而提供的：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>concatenate</td><td>最一般化的连接，沿一条轴连接一组数组</td></tr><tr><td>vstack、row_stack</td><td>以面向行的方式对数组进行堆叠（沿轴o)</td></tr><tr><td>hstack</td><td>以面向列的方式对数组进行堆叠（沿轴1)</td></tr><tr><td>column_stack</td><td>类似于hstack，但是会先将一维数组转换为二维列向量</td></tr><tr><td>dstack</td><td>以面向“深度”的方式对数组进行堆叠（(沿轴2)</td></tr><tr><td>split</td><td>沿指定轴在指定的位置拆分数组</td></tr><tr><td>hsplit、 vsplit、dsplit</td><td>split的便捷化函数，分别沿轴o、轴1、轴2进行拆分</td></tr></tbody></table><hr><h3 id="元素的重复操作：tile和repeat">元素的重复操作：tile和repeat</h3><p>对数组进行重复以产生更大数组的工具主要是<code>repeat</code>和<code>tile</code>这两个函数。<code>repeat</code>会将数组中的各个元素重复一定次数，从而产生一个更大的数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.repeat(<span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>默认情况下，如果传入的是一个整数，则各元素就都会重复那么多次。如果传入的是一组整数，则各元素就可以重复不同的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.repeat([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]))<br></code></pre></td></tr></table></figure><p>对于多维数组，还可以让它们的元素沿指定轴重复：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.repeat(<span class="hljs-number">2</span>, axis=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(arr.repeat(<span class="hljs-number">2</span>, axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>同样，在对多维进行重复时，也可以传入一组整数，这样就会使各切片重复不同的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.repeat([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], axis=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(arr.repeat([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], axis=<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>tile的功能是沿指定轴向堆叠数组的副本。你可以形象地将其想象成“铺瓷砖”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(np.tile(arr, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>第二个参数是瓷砖的数量。对于标量，瓷砖是水平铺设的，而不是垂直铺设。它可以是一个表示“铺设”布局的元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(np.tile(arr, (<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)))<br><span class="hljs-built_in">print</span>(np.tile(arr, (<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)))<br></code></pre></td></tr></table></figure><hr><h2 id="广播">广播</h2><p><strong>广播</strong>（broadcasting）指的是不同形状的数组之间的算术运算的执行方式。它是一种非常强大的功能，但也容易令人误解，即使是经验丰富的老手也是如此。将标量值跟数组合并时就会发生最简单的广播：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr * <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>看一个例子，我们可以通过减去列平均值的方式对数组的每一列进行距平化处理。这个问题解决起来非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.mean(<span class="hljs-number">0</span>))<br><br>demeaned = arr - arr.mean(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(demeaned)<br><br><span class="hljs-built_in">print</span>(demeaned.mean(<span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure><p>下图形象地展示了该过程。用广播的方式对行进行距平化处理会稍微麻烦一些。幸运的是，只要遵循一定的规则，低维度的值是可以被广播到数组的任意维度的（比如对二维数组各列减去行平均值）。</p><p><img src="/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" data-lazy-src="https://img-blog.csdnimg.cn/bb345c94a28d4feda647852d87ed4647.png" alt="广播"><br><img src="/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" data-lazy-src="https://img-blog.csdnimg.cn/fac79e081a114ec8bc413293eb34f09e.png" alt="广播的原则"></p><h3 id="广播规则">广播规则</h3><ol><li>如果两个数组的维度数不相同，那么小维度数组的形状将会在最左边补1。</li><li>如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为1的维度扩展以匹配另外一个数组的形状。</li><li>如果两个数组的形状在任何一个维度上都不匹配并且每一偶任何一个维度等于1，那么会引发异常。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>M = np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br>a = np.arange(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(M.shape)<br><span class="hljs-built_in">print</span>(a.shape)<br></code></pre></td></tr></table></figure><p><strong>根据规则1，数组a的维度数更小，所以在其左边补1：</strong></p><ul><li>M.shape - (2, 3)</li><li>a.shape - (1, 3)</li></ul><p><strong>根据规则2，第一个维度不匹配，因此扩展这个维度以匹配数组：</strong></p><ul><li>M.shape - (2, 3)</li><li>a.shape - (2, 3)</li></ul><p><strong>这样两个数组的形状匹配了，他们最终的形状都是 (2, 3)：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>M = np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br>a = np.arange(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(M + a)<br></code></pre></td></tr></table></figure><p>对于三维的情况，在三维中的任何一维上广播其实也就是将数据重塑为兼容的形状而已。下图说明了要在三维数组各维度上广播的形状需求。</p><p><img src="/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" data-lazy-src="https://img-blog.csdnimg.cn/242415e41ed945a6acc972c17a485404.png" alt="三维广播"><br>于是就有了一个非常普遍的问题（尤其是在通用算法中），即专门为了广播而添加一个长度为1的新轴。虽然<code>reshape</code>是一个办法，但插入轴需要构造一个表示新形状的元组。这是一个很无聊的过程。因此，NumPy数组提供了一种通过索引机制插入轴的特殊语法。下面这段代码通过特殊的<code>np.newaxis</code>属性以及“全”切片来插入新轴：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n----------------\n&quot;</span>)<br>arr_3d = arr[:, np.newaxis, :]<br><span class="hljs-built_in">print</span>(arr_3d)<br><span class="hljs-built_in">print</span>(arr_3d.shape)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr_1d = np.random.normal(size=<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(arr_1d[:, np.newaxis])<br><span class="hljs-built_in">print</span>(arr_1d[np.newaxis, :])<br><span class="hljs-built_in">print</span>(arr_1d.reshape((<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><p>因此，如果我们有一个三维数组，并希望对轴2进行距平化，那么只需要编写下面这样的代码就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>depth_means = arr.mean(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(depth_means)<br><span class="hljs-built_in">print</span>(depth_means.shape)<br>demeaned = arr - depth_means[:, :, np.newaxis]<br><span class="hljs-built_in">print</span>(demeaned.mean(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><hr><h3 id="通过广播设置数组的值">通过广播设置数组的值</h3><p>算术运算所遵循的广播原则同样也适用于通过索引机制设置数组值的操作。对于最简单的情况，我们可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>))<br>arr[:] = <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(arr)<br></code></pre></td></tr></table></figure><p>但是，假设我们想要用一个一维数组来设置目标数组的各列，只要保证形状兼容就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>arr = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>))<br>col = np.array([<span class="hljs-number">1.28</span>, -<span class="hljs-number">0.42</span>, <span class="hljs-number">0.44</span>, <span class="hljs-number">1.6</span>])<br><span class="hljs-built_in">print</span>(col.shape)<br>arr[:] = col[:, np.newaxis]<br><span class="hljs-built_in">print</span>(arr)<br>arr[:<span class="hljs-number">2</span>] = [[-<span class="hljs-number">1.27</span>],[<span class="hljs-number">0.509</span>]]<br><span class="hljs-built_in">print</span>(arr)<br><span class="hljs-built_in">print</span>(arr.flags)<br></code></pre></td></tr></table></figure></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="/img/avatar/2.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="/img/avatar/2.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">小嗷犬</div><div class="post-copyright__author_desc">分享技术，记录生活</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.marquis.eu.org/posts/ee738371/">原创</a><a class="post-copyright-title"><span onclick='rm.copyPageUrl("https://blog.marquis.eu.org/posts/ee738371/")'>Python 数据处理：NumPy库的使用</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/reward/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.png" alt="WeChat Pay"></a><div class="post-qr-code-desc">WeChat Pay</div></li><li class="reward-item"><a href="/img/reward/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.png" alt="Alipay"></a><div class="post-qr-code-desc">Alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display:none"></div><div class="reward-link mode"><a class="reward-link-button" href="/operate/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.marquis.eu.org/posts/ee738371/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Python 数据处理：NumPy库的使用&amp;url=https://blog.marquis.eu.org/posts/ee738371/&amp;pic=https://img-blog.csdnimg.cn/7db7ab3c1cf84fea997611e72efe0b3f.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.marquis.eu.org" target="_blank">小嗷犬</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span> 数据分析<span class="tagsPageCount">5</span></a><a class="post-meta__box__tags" href="/tags/Python/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span> Python<span class="tagsPageCount">43</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4bcdc7f7/"><img class="prev-cover" src="https://img-blog.csdnimg.cn/adc07a697fb7443f874f1561100611b8.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python 类与对象</div></div></a></div><div class="next-post pull-right"><a href="/posts/b5ae3286/"><img class="next-cover" src="https://img-blog.csdnimg.cn/6cc76653eb7b45658123dcb4871223e8.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python 海龟绘图：turtle库的使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size:1.5rem;margin-right:4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/b7f64c96/" title="Pandas 并行计算：Pandarallel 的使用"><img class="cover" src="https://img-blog.csdnimg.cn/direct/c56b069cdb52478f9d9cf0cb729b6e9a.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-01-30</div><div class="title">Pandas 并行计算：Pandarallel 的使用</div></div></a></div><div><a href="/posts/250f9000/" title="Python 数据处理：Pandas库的使用"><img class="cover" src="https://img-blog.csdnimg.cn/ce5a75dacb114925a874cf4ccc9ad3ec.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-09-16</div><div class="title">Python 数据处理：Pandas库的使用</div></div></a></div><div><a href="/posts/7e358d21/" title="2023 年 全国大学生金融科技建模大赛 暨 第四届四川省大学生金融科技建模大赛 初赛数据分析"><img class="cover" src="https://img-blog.csdnimg.cn/d8a89c6abff047eea49cb2047f5c00a8.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-16</div><div class="title">2023 年 全国大学生金融科技建模大赛 暨 第四届四川省大学生金融科技建模大赛 初赛数据分析</div></div></a></div><div><a href="/posts/eb08d4f/" title="数据科学竞赛平台推荐"><img class="cover" src="https://img-blog.csdnimg.cn/direct/eef135f3403a4e479a5ef745e2e7dde1.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-01-12</div><div class="title">数据科学竞赛平台推荐</div></div></a></div><div><a href="/posts/1b55a745/" title="Python bool类型与逻辑关系运算"><img class="cover" src="https://img-blog.csdnimg.cn/adc07a697fb7443f874f1561100611b8.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-10-03</div><div class="title">Python bool类型与逻辑关系运算</div></div></a></div><div><a href="/posts/4364d32d/" title="Python 三元表达式的另类实现"><img class="cover" src="https://img-blog.csdnimg.cn/adc07a697fb7443f874f1561100611b8.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-10-14</div><div class="title">Python 三元表达式的另类实现</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i> <span>评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display:none">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src="/img/avatar/2.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-status"><img class="g-status" src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"></div></div><div class="author-info__description"><div style="line-height:1.38;margin:.6rem 0;text-align:justify;color:rgba(255,255,255,.8)">这有关于<b style="color:#fff">语言、算法、AI</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:.6rem 0;text-align:justify;color:rgba(255,255,255,.8)">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小嗷犬</h1><div class="author-info__desc">分享技术，记录生活</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://marquis.blog.csdn.net/" target="_blank" title="CSDN"><i class="fas fa-c faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://www.kaggle.com/marquis03" target="_blank" title="Kaggle"><i class="fab fa-kaggle faa-tada"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background:url(/img/card_wx/front.png) center center/100% no-repeat"></div><div class="back face" style="background:url(/img/card_wx/back.png) center center/100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NumPy%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">NumPy简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NumPy%E7%9A%84ndarray%EF%BC%9A%E4%B8%80%E7%A7%8D%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">NumPy的ndarray：一种多维数组对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAndarray"><span class="toc-number">2.1.</span> <span class="toc-text">创建ndarray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ndarray%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">ndarray的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NumPy%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.</span> <span class="toc-text">NumPy数组的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%B4%A2%E5%BC%95%E5%92%8C%E5%88%87%E7%89%87"><span class="toc-number">2.4.</span> <span class="toc-text">基本的索引和切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E7%B4%A2%E5%BC%95"><span class="toc-number">2.5.</span> <span class="toc-text">切片索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%9E%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">2.6.</span> <span class="toc-text">布尔型索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95"><span class="toc-number">2.7.</span> <span class="toc-text">花式索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E7%BD%AE%E5%92%8C%E8%BD%B4%E5%AF%B9%E6%8D%A2"><span class="toc-number">2.8.</span> <span class="toc-text">数组转置和轴对换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%9A%84%E5%85%83%E7%B4%A0%E7%BA%A7%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">通用函数：快速的元素级数组函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%BE%93%E5%87%BA"><span class="toc-number">3.1.</span> <span class="toc-text">指定输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88"><span class="toc-number">3.2.</span> <span class="toc-text">聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E7%A7%AF"><span class="toc-number">3.3.</span> <span class="toc-text">外积</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">利用数组进行数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9D%A1%E4%BB%B6%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BF%B0%E4%B8%BA%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97"><span class="toc-number">4.1.</span> <span class="toc-text">将条件逻辑表述为数组运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%92%8C%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">数学和统计方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%B8%83%E5%B0%94%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">用于布尔型数组的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%AE%83%E7%9A%84%E9%9B%86%E5%90%88%E9%80%BB%E8%BE%91"><span class="toc-number">4.5.</span> <span class="toc-text">唯一化以及其它的集合逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">5.</span> <span class="toc-text">用于数组的文件输入输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">线性代数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90"><span class="toc-number">7.</span> <span class="toc-text">伪随机数生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">高级数组操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%87%8D%E5%A1%91"><span class="toc-number">8.1.</span> <span class="toc-text">数组重塑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E5%92%8CFortran%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text">C和Fortran顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%90%88%E5%B9%B6%E5%92%8C%E6%8B%86%E5%88%86"><span class="toc-number">8.3.</span> <span class="toc-text">数组的合并和拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%EF%BC%9Atile%E5%92%8Crepeat"><span class="toc-number">8.4.</span> <span class="toc-text">元素的重复操作：tile和repeat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD"><span class="toc-number">9.</span> <span class="toc-text">广播</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E8%A7%84%E5%88%99"><span class="toc-number">9.1.</span> <span class="toc-text">广播规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%B9%BF%E6%92%AD%E8%AE%BE%E7%BD%AE%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC"><span class="toc-number">9.2.</span> <span class="toc-text">通过广播设置数组的值</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/6062c529/" title="【论文笔记】Sign Language Video Retrieval with Free-Form Textual Queries"><img src="https://i-blog.csdnimg.cn/direct/8440705e97cd474ea81703fa5d0afbae.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="【论文笔记】Sign Language Video Retrieval with Free-Form Textual Queries"></a><div class="content"><a class="title" href="/posts/6062c529/" title="【论文笔记】Sign Language Video Retrieval with Free-Form Textual Queries">【论文笔记】Sign Language Video Retrieval with Free-Form Textual Queries</a><time datetime="2025-01-12T09:51:53.000Z" title="发表于 2025-01-12 17:51:53">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/af8b765f/" title="【论文笔记】PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models"><img src="https://i-blog.csdnimg.cn/direct/6c07a7a5e578400c95f2e6218f53c8ea.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="【论文笔记】PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models"></a><div class="content"><a class="title" href="/posts/af8b765f/" title="【论文笔记】PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models">【论文笔记】PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models</a><time datetime="2025-01-05T14:30:30.000Z" title="发表于 2025-01-05 22:30:30">2025-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dc5a7551/" title="【论文笔记】Direct Preference Optimization: Your Language Model is Secretly a Reward Model"><img src="https://i-blog.csdnimg.cn/direct/5dca8b5cb9904b4aa94d3a737d2e0295.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="【论文笔记】Direct Preference Optimization: Your Language Model is Secretly a Reward Model"></a><div class="content"><a class="title" href="/posts/dc5a7551/" title="【论文笔记】Direct Preference Optimization: Your Language Model is Secretly a Reward Model">【论文笔记】Direct Preference Optimization: Your Language Model is Secretly a Reward Model</a><time datetime="2025-01-05T13:44:55.000Z" title="发表于 2025-01-05 21:44:55">2025-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5301fcd1/" title="【论文笔记】LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models"><img src="https://i-blog.csdnimg.cn/direct/d8ae3ba314174e979eb534800bca9b6a.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="【论文笔记】LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models"></a><div class="content"><a class="title" href="/posts/5301fcd1/" title="【论文笔记】LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models">【论文笔记】LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models</a><time datetime="2025-01-05T13:00:39.000Z" title="发表于 2025-01-05 21:00:39">2025-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f9e2309d/" title="【论文笔记】NEFTune: Noisy Embeddings Improve Instruction Finetuning"><img src="https://i-blog.csdnimg.cn/direct/fd9354b9f1774dcba4609bf7751e7340.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="【论文笔记】NEFTune: Noisy Embeddings Improve Instruction Finetuning"></a><div class="content"><a class="title" href="/posts/f9e2309d/" title="【论文笔记】NEFTune: Noisy Embeddings Improve Instruction Finetuning">【论文笔记】NEFTune: Noisy Embeddings Improve Instruction Finetuning</a><time datetime="2025-01-05T12:17:40.000Z" title="发表于 2025-01-05 20:17:40">2025-01-05</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://marquis.blog.csdn.net/" title="CSDN"><i class="fas fa-c"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.kaggle.com/marquis03" title="Kaggle"><i class="fab fa-kaggle"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/97020105" title="BiliBili"><i class="fab fa-bilibili"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0,500)" src="/img/doge.gif" size="50px"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/Marquis03" title="Github"><i class="fab fa-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://qm.qq.com/q/kvSr7oUR6U" title="QQ"><i class="fab fa-qq"></i></a><a class="deal_link" href="mailto:marquis128@foxmail.com" title="Email"><i class="fas fa-envelope"></i></a></div><div id="workboard"><img class="workSituationImg boardsign" src="/img/footer/小嗷犬-上班摸鱼中-007ACC.svg" alt="距离月入30k也就还差一个大佬带我~" title="距离月入30k也就还差一个大佬带我~"><div id="runtimeTextTip"></div></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="网站收藏" href="/favorites/">网站收藏</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="本站框架为Hexo" title="本站框架为Hexo"><img src="/img/footer/Frame-Hexo-blue.svg" alt="本站框架为Hexo"></a><a class="github-badge" target="_blank" href="https://docs.anheyu.com/" style="margin-inline:5px" data-title="本站主题采用AnZhiYu" title="本站主题采用AnZhiYu"><img src="/img/footer/Theme-AnZhiYu-2E67D3.svg" alt="本站主题采用AnZhiYu"></a><a class="github-badge" target="_blank" href="https://www.netlify.com/" style="margin-inline:5px" data-title="本站部署于Netlify" title="本站部署于Netlify"><img src="/img/footer/Hosted-Netlify-00C7B7.svg" alt="本站部署于Netlify"></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20222350" style="margin-inline:5px" data-title="本站已加入萌ICP豪华套餐，萌ICP备20222350号" title="本站已加入萌ICP豪华套餐，萌ICP备20222350号"><img src="/img/footer/萌ICP备-20222350-fe1384.svg" alt="本站已加入萌ICP豪华套餐，萌ICP备20222350号"></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站源码托管于Github" title="本站源码托管于Github"><img src="/img/footer/Source-Github-d021d6.svg" alt="本站源码托管于Github"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="/img/footer/Copyright-BY--NC--SA 4.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="小嗷犬" target="_blank">小嗷犬</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" href="/atom.xml" title="RSS订阅">RSS订阅</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">186</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://marquis.eu.org/" title="个人主页"><img class="back-menu-item-icon" src="/img/avatar/1.png" alt="个人主页"><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" href="https://blog.marquis.eu.org/" title="个人博客"><img class="back-menu-item-icon" src="/img/avatar/2.png" alt="个人博客"><span class="back-menu-item-text">个人博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="fas fa-chart-bar faa-tada"></i> <span>统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8947107806&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i> <span>相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/favorites/"><i class="fas fa-star faa-tada"></i> <span>收藏夹</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size:.9em"></i> <span>装备栏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i> <span>友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i> <span>关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size:.9em"></i> <span>闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i> <span>随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size:.88rem">C<sup>1</sup></a><a href="/tags/CPP/" style="font-size:.88rem">CPP<sup>5</sup></a><a href="/tags/LaTeX/" style="font-size:.88rem">LaTeX<sup>4</sup></a><a href="/tags/Linux/" style="font-size:.88rem">Linux<sup>1</sup></a><a href="/tags/MATLAB/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">MATLAB<sup>28</sup></a><a href="/tags/Markdown/" style="font-size:.88rem">Markdown<sup>5</sup></a><a href="/tags/Python/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">Python<sup>43</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size:.88rem">前端<sup>1</sup></a><a href="/tags/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB/" style="font-size:.88rem">动作识别<sup>2</sup></a><a href="/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/" style="font-size:.88rem">多任务<sup>1</sup></a><a href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/" style="font-size:.88rem">多模态<sup>41</sup></a><a href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" style="font-size:.88rem">大模型<sup>44</sup></a><a href="/tags/%E5%B0%91%E6%A0%B7%E6%9C%AC/" style="font-size:.88rem">少样本<sup>4</sup></a><a href="/tags/%E5%BE%AE%E8%B0%83/" style="font-size:.88rem">微调<sup>11</sup></a><a href="/tags/%E6%89%8B%E8%AF%AD%E7%BF%BB%E8%AF%91/" style="font-size:.88rem">手语翻译<sup>21</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:.88rem">操作系统<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" style="font-size:.88rem">数学建模<sup>20</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size:.88rem">数据分析<sup>5</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/" style="font-size:.88rem">数据可视化<sup>2</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size:.88rem">机器学习<sup>8</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size:.88rem">深度学习<sup>19</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size:.88rem">爬虫<sup>5</sup></a><a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" style="font-size:.88rem">程序设计<sup>11</sup></a><a href="/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" style="font-size:.88rem">论文笔记<sup>66</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8947107806" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.5"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"><a class="tag-list" href="/tags/Python" title="Python">Python</a><a class="tag-list" href="/tags/MATLAB" title="MATLAB">MATLAB</a></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8947107806&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>var meting_api="https://api.injahow.cn/meting/?server=:server&type=:type&id=:id&auth=:auth&r=:r"</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script async>!function(){var e,t,n,r,o,i=new Date("01/16/2023 00:00:00"),a=new Date;setInterval((()=>{!function(){a=new Date,o=a.getHours();var l=(a-i)/1e3/60/60/24;e=Math.floor(l);var u=(a-i)/1e3/60/60-24*e;t=Math.floor(u),1==String(t).length&&(t="0"+t);var c=(a-i)/1e3/60-1440*e-60*t;n=Math.floor(c),1==String(n).length&&(n="0"+n);var s=(a-i)/1e3-86400*e-3600*t-60*n;r=Math.round(s),1==String(r).length&&(r="0"+r)}(),function(){if(!document.getElementById("footer"))return;let i="";if(o<18&&o>=9)i=`本站居然运行了 ${e} 天<span id='runtime'> ${t} 小时 ${n} 分 ${r} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;else{let o=document.querySelector("#workboard .workSituationImg");null!=o&&(o.src="/img/footer/小嗷犬-下班摆烂啦-2F2625.svg",o.title="下班了就该开开心心的玩耍，嘿嘿~",o.alt="下班了就该开开心心的玩耍，嘿嘿~"),i=`本站居然运行了 ${e} 天<span id='runtime'> ${t} 小时 ${n} 分 ${r} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`}document.getElementById("runtimeTextTip")&&(document.getElementById("runtimeTextTip").innerHTML=i)}()}),1e3)}()</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.cbd.int/katex@0.16.0/dist/katex.min.css"><script src="https://cdn.cbd.int/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{anzhiyu.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const t=()=>{"object"==typeof twikoo?setTimeout(o,0):getScript("https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js").then(o)},o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.marquis.eu.org/",region:"",onCommentLoaded:()=>{anzhiyu.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.marquis.eu.org/",region:"",urls:[window.location.pathname],includeReply:!1}).then((o=>{t.textContent=o[0].count})).catch((t=>{console.error(t)}))})()};t()})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener("load",(()=>{const e=e=>{let t="";if(e.length)for(let n=0;n<e.length;n++){t+="<div class='aside-list-item'>";{const a="data-lazy-src";t+=`<a href='${e[n].url}' class='thumbnail'><img ${a}='${e[n].avatar}' alt='${e[n].nick}'><div class='name'><span>${e[n].nick} </span></div></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[n].url}' title='${e[n].content}'>${e[n].content}</a>\n        <time datetime="${e[n].date}">${anzhiyu.diffDate(e[n].date,!0)}</time></div>\n        </div>`}else t+="没有评论";let n=document.querySelector("#card-newest-comments .aside-list");n&&(n.innerHTML=t),window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(n)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("twikoo-newest-comments");t?e(JSON.parse(t)):(()=>{const t=()=>{twikoo.getRecentComments({envId:"https://twikoo.marquis.eu.org/",region:"",pageSize:6,includeReply:!0}).then((function(t){const n=t.map((e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.id,date:new Date(e.created).toISOString()};var t}));saveToLocal.set("twikoo-newest-comments",JSON.stringify(n),10/1440),e(n)})).catch((function(e){document.querySelector("#card-newest-comments .aside-list").textContent="无法获取评论，请确认相关配置是否正确"}))};"object"==typeof twikoo?t():getScript("https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js").then(t)})()}};t(),document.addEventListener("pjax:complete",t)}))</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script defer src="/js/console.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]','meta[property="og:type"]','meta[property="og:site_name"]','meta[property="og:description"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(anzhiyu.removeGlobalFnEvent("pjax"),anzhiyu.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>