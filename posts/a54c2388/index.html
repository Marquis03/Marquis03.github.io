<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>C++ 程序设计入门 | 小嗷犬</title><meta name="keywords" content="CPP,程序设计"><meta name="author" content="小嗷犬"><meta name="copyright" content="小嗷犬"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C++ 程序设计入门"><meta name="application-name" content="C++ 程序设计入门"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C++ 程序设计入门"><meta property="og:url" content="https://blog.marquis.eu.org/posts/a54c2388/index.html"><meta property="og:site_name" content="小嗷犬"><meta property="og:description" content="程序是算法与数据结构的载体，是计算机用以解决问题的工具。 而在程序设计比赛中，最主流的语言是 C++。 学习编程是学习程序设计最 基础 的部分。 如何开始 环境配置 工欲善其事，必先利其器。 集成开发环境（IDE） IDE 是 Integrated Development Environment 的"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img-blog.csdnimg.cn/53244566b46c41bb95f2a0e463f21bae.png"><meta property="article:author" content="小嗷犬"><meta property="article:tag" content="Python, 人工智能, 深度学习, 爬虫, 数据分析, 数据可视化, 小嗷犬, PWA"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img-blog.csdnimg.cn/53244566b46c41bb95f2a0e463f21bae.png"><meta name="description" content="程序是算法与数据结构的载体，是计算机用以解决问题的工具。 而在程序设计比赛中，最主流的语言是 C++。 学习编程是学习程序设计最 基础 的部分。 如何开始 环境配置 工欲善其事，必先利其器。 集成开发环境（IDE） IDE 是 Integrated Development Environment 的"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.marquis.eu.org/posts/a54c2388/"><link rel="preconnect" href="//cdn.cbd.int"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="7oHto6XqE_zXYM7itwHoZTeb47PULzcAxenBeT1h-c4"><meta name="baidu-site-verification" content="codeva-izBOFPih2F"><meta name="msvalidate.01" content="390C5F1424AB7444F1B8E05DA02232BF"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="var(--anzhiyu-main)"><link rel="mask-icon" href="/img/siteicon/apple-touch-icon.png" color="#5bbad5"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/siteicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/favicon-16x16.png"><link rel="bookmark" href="/img/siteicon/apple-icon-180.png"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1290-2796.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2796-1290.jpg" media="(device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1179-2556.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2556-1179.jpg" media="(device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="/img/siteicon/apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?368c140290209ced69f65d67bf17e5fd";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG={linkPageTop:{enable:!0,title:"与数百名博主无限进步",addFriendPlaceholder:"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},peoplecanvas:void 0,postHeadAiDescription:{enable:!0,gptName:"小嗷犬",mode:"local",switchBtn:!1,btnLink:"https://afdian.net/item/886a79d4db6711eda42a52540025c377",randomNum:3,basicWordCount:1e3,key:"xxxx",Referer:"https://xx.xx/"},diytitle:{enable:!0,leaveTitle:"w(ﾟДﾟ)w 不要走！再看看嘛！",backTitle:"♪(^∇^*)欢迎肥来！"},LA51:{enable:!0,ck:"JwZrZwQa4gtWzwsr",LingQueMonitorID:"JwcZGiBSGG3rSvij"},greetingBox:{enable:!0,default:"晚上好👋",list:[{greeting:"晚安😴",startTime:0,endTime:5},{greeting:"早上好鸭👋, 祝你一天好心情！",startTime:6,endTime:9},{greeting:"上午好👋, 状态很好，鼓励一下～",startTime:10,endTime:10},{greeting:"11点多啦, 在坚持一下就吃饭啦～",startTime:11,endTime:11},{greeting:"午安👋, 宝贝",startTime:12,endTime:14},{greeting:"🌈充实的一天辛苦啦！",startTime:14,endTime:18},{greeting:"19点喽, 奖励一顿丰盛的大餐吧🍔。",startTime:19,endTime:19},{greeting:"晚上好👋, 在属于自己的时间好好放松😌~",startTime:20,endTime:24}]},twikooEnvId:"https://twikoo.marquis.eu.org/",commentBarrageConfig:{enable:!0,maxBarrage:1,barrageTime:4e3,accessToken:"",mailMd5:"29ae50b4bc2db4bc06b67953cffcde91"},root:"/",preloader:{source:3},friends_vue_info:void 0,navMusic:!0,mainTone:{mode:"api",api:"https://img2color.marquis.eu.org/api?img=",cover_change:!0},authorStatus:{skills:["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},algolia:{appId:"DVYRTF6D9Z",apiKey:"f2a8d629317821324cdf3875087d3364",indexName:"blog",hits:{per_page:6},languages:{input_placeholder:"输入关键词后按下回车查找",hits_empty:"找不到您查询的内容：${query}",hits_stats:"找到 ${hits} 条结果，用时 ${time} 毫秒"}},localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简",rightMenuMsgToTraditionalChinese:"转为繁体",rightMenuMsgToSimplifiedChinese:"转为简体"},noticeOutdate:{limitDay:365,position:"top",messagePrev:"这篇文章距离上次更新已经过去了",messageNext:"天，其中的某些内容可能不再适用了，请谨慎阅读。"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:400},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,simplehomepage:!0,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{copy:!0,copyrightEbable:!0,limitCount:50,languages:{author:"作者: 小嗷犬",link:"链接: ",source:"来源: 小嗷犬",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",copySuccess:"复制成功，复制和转载请标注本文地址"}},lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#425AEF",bgDark:"#1f1f1f",position:"top-center"},source:{justifiedGallery:{js:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js",css:"https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!1,shortcutKey:void 0,autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={configTitle:"小嗷犬",title:"C++ 程序设计入门",postAI:"本文以“C++ 程序设计入门”为主题，旨在帮助读者掌握 C++ 编程的基础知识。从环境配置、集成开发环境（IDE）和编译器的选择开始，博客详细介绍了 C++ 的语法基础，包括代码框架、include 指令、namespace 命名空间和 main 函数等。读者将了解注释的用法，以及如何进行输入与输出操作，涵盖 cin 与 cout、scanf 与 printf 等方法。接着，博客深入讲解了变量和数据类型，包括布尔类型、整数类型、字符类型、浮点类型和无类型，以及类型转换的相关知识。运算部分详细介绍了算术运算符、位运算符、自增/自减运算符等，并提供了运算符优先级总表。在流程控制部分，博客涵盖了分支结构（ if 语句和 switch 语句）和循环结构（for 循环、while 循环和 do...while 循环），并介绍了 break 和 continue 语句。高级数据类型方面，博客讲解了数组的定义和访问、结构体的使用，以及指针的概念和应用。最后，博客还介绍了函数的声明、定义和调用，以及文件操作和模板的基本知识。通过阅读本博客，读者将建立起 C++ 编程的基础，为进一步深入学习和开发 C++ 应用程序打下坚实的基础。",pageFillDescription:"如何开始, 环境配置, 集成开发环境（IDE）, 编译器, 第一个 C++ 程序, C++ 语法基础, 代码框架, 什么是 include, 什么是 namespace, 什么是 main 函数, 注释, 输入与输出, cin 与 cout, scanf 与 printf, 扩展内容, endl 与 ‘\n’, C++ 中的空白字符, define 命令, 变量, 数据类型, 布尔类型, 整数类型, 字符类型, 浮点类型, 无类型, 类型转换, 数值提升, 整数提升, 浮点提升, 数值转换, 整数转换, 浮点转换, 浮点整数转换, 布尔转换, 定义变量, 变量作用域, 常量, 运算, 算术运算符, 算术运算中的类型转换, 位运算符, 自增/自减 运算符, 复合赋值运算符, 条件运算符, 比较运算符, 逻辑运算符, 逗号运算符, 成员访问运算符, C++ 运算符优先级总表, 流程控制, 分支结构, if 语句, 基本 if 语句, if…else 语句, else if 语句, switch 语句, 循环结构, for 循环, while 循环, do…while 循环, 三种循环的联系, break 与 continue 语句, 高级数据类型, 数组, 定义数组, 访问数组元素, 越界访问下标, 多维数组, 结构体, 定义结构体, 访问/修改成员元素, 结构体的意义, 结构体的弊端, 指针, 变量的地址、指针, 指针的声明与使用, 指针的偏移, 使用指针偏移访问数组, 空指针, 指针的进阶使用, 指针类型参数的使用, 动态实例化, 动态创建数组, 二维数组, 动态创建二维数组, 指向函数的指针, 函数, 函数的声明, 实现函数：编写函数的定义, 函数的调用, main 函数, 文件操作, 文件的概念, 文件的操作步骤, freopen 函数, 函数简介, 函数原型, 参数说明, 文件打开格式, 使用方法, 模板, fopen 函数（选读）, 函数原型, 可用读写函数（基本）, 使用方式, C++ 的 ifstream / ofstream 文件输入输出流, 使用方法, 模板, 参考资料程序是算法与数据结构的载体是计算机用以解决问题的工具而在程序设计比赛中最主流的语言是学习编程是学习程序设计最基础的部分如何开始环境配置工欲善其事必先利其器集成开发环境是的缩写即集成开发环境它包括了代码编辑器编译器调试器等程序从编写到运行的一系列工具配置较为简单适合入门玩家在竞赛中最常见的是的优点在于界面简洁友好安装便捷支持单文件编译因此成为了许多入门程序设计选手以及语言初学者的首选起源于编写的该版本自年月日停止更新后续又有等衍生版本以上的分发都被认为是官方的此外在年停止更新后因为教学需要一位来自中国的个人开发者决定继续开发他的个人分支命名为小熊猫集成了智能提示和高版本的非常便于国内的个人使用和学习项目官网位于小熊猫源代码托管于小熊猫官网也提供了相应的小熊猫入门教程本文推荐使用小熊猫来进行的学习编译器除了使用之外我们也可以使用编译器来编译我们的代码这么做的好处是可以分离程序的编写和编译过程使得我们可以选择更加适合自己的代码编辑器同时也可以使用命令行更灵活地编译我们的代码常见的编译器有等配置相较于来说稍微复杂一些适合已经对有一定理解的玩家第一个程序通过编写一个简单的示例程序来开始我们的之旅吧引用输入输出流头文件使用标准命名空间定义函数输出并换行返回表示程序正常结束与它相对应的语言版本如下引用标准输入输出头文件定义函数输出并换行返回表示程序正常结束注意本文的语言代码仅做参考基本上兼容语言并且拥有许多新的功能可以让选手在赛场上事半功倍语法基础代码框架如果你不想深究背后的原理初学时可以直接将这个框架背下来什么是其实是一个预处理命令意思为将一个文件放在这条语句处被放的文件被称为头文件也就是说在编译时编译器会复制头文件中的内容粘贴到这条语句处这样你就可以使用中提供的等对象了如果你学过语言你会发现目前我们接触的中的头文件一般都不带后缀而那些语言中的头文件都变成了如变成了因为为了和保持兼容都直接使用了语言中的头文件为了区分的头文件和的头文件使用了前缀通常情况下我们只需要自己所需的头文件比如上文的和引入它们就可以使用来进行输入输出了什么是是命名空间的意思的命名空间机制可以用来解决复杂项目中名字冲突的问题举个例子标准库的所有内容均定义在命名空间中如果你定义了一个叫的变量则可以通过来访问你定义的变量通过访问标准库的对象而不用担心产生冲突如果你不想每次都写可以使用来引入命名空间这样你就可以直接使用等对象了什么是函数可以理解为程序运行时就会执行中的代码实际上函数是由系统或外部程序调用的如你在命令行中调用了你的程序也就是调用了你程序中的函数最后的表示程序运行成功默认情况下程序结束时返回表示一切正常否则返回值表示错误代码这个值返回给谁呢其实就是调用你写的程序的系统或外部程序它会在你的程序结束时接收到这个返回值如果不写语句的话程序正常结束默认返回值也是在或中程序的返回值不为会导致运行时错误注释在代码中注释有两种写法单行注释多行注释程序运行没有影响可以用来解释程序的意思还可以在让某段代码不执行但是依然保留在源文件里在工程开发中注释可以便于日后维护他人阅读在程序设计比赛中很少有人写大段的注释但注释可以便于在写代码的时候理清思路或者便于日后复习而且如果要写题解教程的话适量的注释可以便于读者阅读理解代码的意图因此写注释是一个好习惯输入与输出与在中我们可以使用和来进行输入输出定义两个类型的变量和输入和输出换行输出换行上面程序中和分别是输入流和输出流的对象和分别是输入运算符和输出运算符如何理解输入输出流呢我们可以把数据流想象成水流是一个水龙头是一个排水口变量和是两个容器和是连接水龙头和容器排水口和容器的管道的意思就是将水龙头的水流输入到容器中的意思就是将容器中的水流输出到排水口运算符的方向总是指向数据流的方向事实上上述的比喻并不严谨因为变量是有多种类型的这意味着容器也有多种类型自然数据流中就不会只有水这一种液体关于变量的知识我们将在后面的章节中进行介绍与与其实是语言提供的函数大多数情况下它们的速度比和更快并且能够方便地控制输入输出格式输入和输出换行再输出换行这段代码与相同功能的语言代码只有头文件的差别其中表示读入输出的变量是一个有符号整型型的变量这样的符号称为格式控制符用来控制输入输出的格式常用的控制符有控制符说明字符串字符有符号十进制整数或依系统而定长整型双精度浮点数无符号十进制整数或依系统而定无符号长整型格式控制符除了能表示类型外还能够控制格式常用的有控制符说明长度为的整型在读入时即使没有空格也可以逐位读入数字在输出时若指定的长度大于数字的位数就会在数字前用空格填充若指定的长度小于数字的位数就没有效果用于输出保留位小数上面两个格式控制符相应位置填入不同数字就会有不同的效果如表示保留位小数扩展内容与是中的一个操作符它的作用是插入一个换行符并刷新输出缓冲区事实上等价于大部分情况下和运行起来并无明显区别除非题目要求你输出之后立即刷新缓冲区说的就是你交互题中的空白字符在中所有空白字符空格制表符换行多个或是单个都被视作是一样的当然引号中视作字符串的一部分的不算因此你可以自由地使用任何代码风格除了行内注释字符串字面量与预处理命令必须在单行内例如这段程序和上文写的程序一样能够完成相同的事情读入两个整数然后先输出第二个整数再输出第一个整数每输出一个整数换一行当然这么做是不被推荐的命令是一种预处理命令用于定义宏本质上是文本替换例如不是变量而是编译器会将代码中所有文本替换为但是作为标识符一部分的的就不会被替换如不会被替换成同样字符串内的也不会被替换输出宏可以带参数带参数的宏可以像函数一样使用输出但是带参数的宏和函数有区别因为宏是文本替换所以会引发许多问题如这里应当为输出为因为是文本替换后面的语句被替换为了输出未定义因为被执行了两遍而同一个语句中多次修改同一个变量是未定义行为有例外因此使用是有风险的应谨慎使用变量数据类型的类型系统主要由如下几部分组成基础类型括号内为代表关键词代表类型无类型型起空指针类型算术类型整数类型布尔类型型字符类型浮点类型复合类型布尔类型一个类型的变量取值只可能为两种和一般情况下一个类型变量占有字节一般情况下字节位的空间整数类型用于存储整数最基础的整数类型是整数类型一般按位宽有个梯度标准保证但对于每种类型的位宽并没有做出具体的规定对于关键字可以使用如下修饰关键字进行修饰符号性有符号的默认无符号的大小短整型长整型长长整型下表给出了各个类型的等价形式和位宽类型等价形式位宽标准位宽常见对于整数类型当位宽为时有符号类型的表示范围为无符号类型的表示范围为程序设计中最常用的两个整数类型是和字符类型分为窄字符类型和宽字符类型由于程序设计竞赛几乎不会用到宽字符类型故此处仅介绍窄字符类型窄字符型位数一般为位实际上底层存储方式仍然是整数一般通过编码实现字符与整数的一一对应有如下三种有符号字符表示的类型表示范围在之间无符号字符表示的类型表示范围在之间有符号或无符号字符表示的类型具体由编译器决定事实上只有类型的变量才应该用于表示字符和类型通常被视为整数类型浮点类型用于存储实数注意并不是严格意义上的实数而是实数在一定规则下的近似包括以下三种单精度浮点类型如果支持就会匹配格式双精度浮点类型如果支持就会匹配格式扩展精度浮点类型如果支持就会匹配格式否则如果支持就会匹配扩展格式否则匹配某种精度优于而值域至少和一样好的非扩展浮点格式否则匹配格式浮点格式位宽最大正数精度位数格式格式扩展格式格式浮点格式的最小负数是最大正数的相反数因为类型表示范围较小且精度不高实际应用中常使用类型表示浮点数除此之外浮点类型可以支持一些特殊值正负无穷负零例如非数一般可以由之类的运算产生它与任何值包括自身比较都不相等后可以使用判断一个浮点数是不是无类型类型为无类型与上面几种类型不同的是不能将一个变量声明为类型但是函数的返回值允许为类型表示该函数无返回值类型转换在一些时候比如某个函数接受类型的参数但传入了类型的变量我们需要将某种类型转换成另外一种类型中类型的转换机制较为复杂这里主要介绍对于基础数据类型的两种转换数值提升和数值转换数值提升数值提升过程中值本身保持不变不会产生精度损失整数提升小整数类型如的纯右值可转换成较大整数类型如的纯右值具体而言算术运算符不接受小于的类型作为它的实参而在左值到右值转换后如果适用就会自动实施整数提升具体地有如下规则源类型为时可提升为源类型为时若能保有源类型的值范围则可提升为否则可提升为的提升规则取决于其底层类型是还是类型可转换到变为变为若目标类型的值范围包含源类型且源类型的值范围不能被和包含则源类型可提升为目标类型浮点提升位宽较小的浮点数可以提升为位宽较大的浮点数例如类型的变量和类型的变量进行算术运算时会将类型变量提升为类型变量其值不变数值转换数值转换过程中值可能会发生改变可能会产生精度损失注意数值提升优先于数值转换如时是数值提升而非数值转换整数转换如果目标类型为位宽为的无符号整数类型则转换结果是原值后的结果若目标类型位宽大于源类型位宽若源类型为有符号类型一般情况下需先进行符号位扩展再转换若源类型为无符号类型则需先进行零扩展再转换若目标类型位宽不大于源类型位宽则需先截断再转换如果目标类型为位宽为的带符号整数类型则一般情况下转换结果可以认为是原值后的结果如果目标类型是则是布尔转换如果源类型是则转为对应类型的转为对应类型的浮点转换位宽较大的浮点数转换为位宽较小的浮点数会将该数舍入到目标类型下最接近的值浮点整数转换浮点数转换为整数时会舍弃浮点数的全部小数部分如果目标类型是则是布尔转换整数转换为浮点数时会舍入到目标类型下最接近的值如果该值不能适应到目标类型中那么行为未定义如果源类型是那么转换为而转换为布尔转换将其他类型转换为类型时零值转换为非零值转换为定义变量简单来说定义一个变量需要包含类型说明符指明变量的类型以及要定义的变量名例如下面这几条语句都是变量定义语句在目前我们所接触到的程序段中定义在花括号内部的变量是局部变量而定义在所有花括号外部的变量是全局变量实际有例外但是现在不必了解定义时没有初始化值的全局变量会被初始化为而局部变量没有这种特性需要手动赋初始值否则可能引起难以发现的变量作用域变量的作用域是指变量在程序中有效的范围全局变量的作用域自其定义之处开始至文件结束位置为止局部变量的作用域自其定义之处开始至代码块结束位置为止由一对大括号括起来的若干语句构成一个代码块定义全局变量定义局部变量输出如果一个代码块的内嵌块中定义了相同变量名的变量则内层块中将无法访问外层块中相同变量名的变量例如上面的代码中输出的的值将是因此为了防止出现意料之外的错误请尽量避免局部变量与全局变量重名的情况常量常量又称常变量值为固定值在程序执行期间不会改变常量的值在定义后不能被修改定义时加一个关键字即可如果修改了常量的值在编译环节就会报错运算算术运算符运算符功能单目取正单目取负乘法除法取模加法减法单目运算符又称一元运算符指被操作对象只有一个的运算符而双目运算符又称二元运算符的被操作对象有两个例如中加号就是双目运算符它有和两个被操作数算术运算符中有两个单目运算符取正取负以及五个双目运算符乘法除法取模加法减法其中单目运算符的优先级最高其中取模运算符意为计算两个整数相除得到的余数即求余数中的算术运算遵循数学中加减乘除的优先规律首先进行优先级高的运算同优先级自左向右运算括号提高优先级算术运算中的类型转换对于双目算术运算符当参与运算的两个变量类型相同时不发生类型转换运算结果将会用参与运算的变量的类型容纳否则会发生类型转换以使两个变量的类型一致转换的规则如下先将等类型提升至或取决于原类型的符号性类型若存在一个变量类型为会将另一变量转换为类型否则若存在一个变量类型为会将另一变量转换为类型否则若存在一个变量类型为会将另一变量转换为类型否则即参与运算的两个变量均为整数类型若两个变量符号性一致则将位宽较小的类型转换为位宽较大的类型否则若无符号变量的位宽不小于带符号变量的位宽则将带符号数转换为无符号数对应的类型否则若带符号操作数的类型能表示无符号操作数类型的所有值则将无符号操作数转换为带符号操作数对应的类型否则将带符号数转换为相对应的无符号类型例如对于一个整型变量和另一个双精度浮点型类型变量的结果将会是整型的结果将会是双精度浮点型的结果将会是双精度浮点型的结果将会是整型的结果将会是双精度浮点型位运算符运算符功能单目按位非按位与按位或按位异或按位左移按位右移位运算就是基于整数的二进制表示进行的运算由于计算机内部就是以二进制来存储数据位运算是相当快的需要注意的是位运算符的优先级低于普通的算数运算符自增自减运算符有时我们需要让变量进行增加自增或者减少自减这时自增运算符和自减运算符就派上用场了自增自减运算符可放在变量前或变量后面在变量前称为前缀在变量后称为后缀单独使用时前缀后缀无需特别区别如果需要用到表达式的值则需注意具体可看下面的例子先然后先然后赋值先赋值然后先然后赋值复合赋值运算符复合赋值运算符实际上是表达式的缩写形式可分为复合算术运算符和复合位运算符例如可写为可写为可写为条件运算符条件运算符可以看作语句的简写中如果表达式成立那么这个条件表达式的结果是否则条件表达式的结果是条件运算符是中唯一的三目运算符所以平常说的三目运算符就是指条件运算符比较运算符运算符功能大于大于等于小于小于等于等于不等于其中特别需要注意的是要将等于运算符和赋值运算符区分开来这在判断语句中尤为重要与看起来类似但实际功能却相差甚远第一条语句是在对进行赋值若赋值为非时为真值表达式的条件始终是满足的无法达到判断的作用而第二条语句才是对的值进行判断逻辑运算符运算符功能逻辑与逻辑或逻辑非当与都为真时则为真当或其中一个为真时则为真当为假时则为真逗号运算符逗号运算符可将多个表达式分隔开来被分隔开的表达式按从左至右的顺序依次计算整个表达式的值是最后的表达式的值逗号表达式的优先级在所有运算符中的优先级是最低的最后的值为的运算结果得到的值为而不是因为赋值运算符的优先级比逗号运算符高先进行了赋值运算才进行逗号运算得到的值为若要让的值得到逗号运算的结果则应将整个表达式用括号提高优先级成员访问运算符运算符功能数组下标对象成员单目取地址获取引用单目间接寻址解引用指针成员这些运算符用来访问对象的成员或者内存这里还省略了两个很少用到的运算符和其具体用法可以参见语言手册获取中下标为的对象获取对象的成员获取指针指向的对象的成员等价于获取指向的指针获取指针指向的对象运算符优先级总表来自运算符优先级有修改优先级运算符描述结合性作用域解析从左到右后缀自增后缀自减函数风格转型函数调用下标访问成员访问从左到右前缀自增前缀自减取正取负逻辑非按位非风格转型间接寻址解引用取地址获取引用返回类型大小动态元素类型分配动态数组类型分配动态析构元素内存动态析构数组内存从右到左类对象成员引用类指针成员引用从左到右乘法除法取模从左到右加法减法从左到右左移右移从左到右三路比较从左到右小于小于等于大于大于等于从左到右等于不等于从左到右按位与从左到右按位异或从左到右按位或从左到右逻辑与从左到右逻辑或从左到右条件运算符抛出异常赋值加赋值减赋值乘赋值除赋值取模赋值左移赋值右移赋值按位与赋值按位异或赋值按位或赋值从右到左逗号从左到右流程控制分支结构一个程序默认是按照代码的顺序执行下来的有时我们需要选择性的执行某些语句这时候就需要分支的功能来实现选择合适的分支语句可以提高程序的效率语句基本语句条件主体语句通过对条件进行求值若结果为真非执行语句否则不执行如果主体中只有单个语句的话花括号可以省略语句条件主体主体语句和语句类似不需要再写条件当语句的条件满足时会执行里的语句语句的条件不满足时会执行里的语句同样当主体只有一条语句时可以省略花括号语句条件主体条件主体条件主体主体语句是和的组合对多个条件进行判断并选择不同的语句分支在最后一条的语句不需要再写条件例如若条件为真执行主体条件为真而条件和条件都为假执行主体所有的条件都为假才执行主体实际上这一个语句相当于第一个的分句只有一个语句就将花括号省略之后放在一起了如果条件相互之间是并列关系这样写可以让代码的逻辑更清晰语句选择句标签主体标签主体主体语句执行时先求出选择句的值然后根据选择句的值选择相应的标签从标签处开始执行其中选择句必须是一个整数类型表达式而标签都必须是整数类型的常量例如这里的的数据类型是整型满足整数类型的表达式的要求这里的的数据类型是字符型但也是属于整数的类型满足整数类型的表达式的要求语句中还要根据需求加入语句进行中断否则在对应的被选择之后接下来的所有里的语句和里的语句都会被运行具体例子可看下面的示例以上代码运行后输出的结果为和如果不想让下面分支的语句被运行就需要了具体例子可看下面的示例以上代码运行后输出的结果为因为的存在接下来的语句就不会继续被执行了最后一个语句不需要因为下面没有语句了处理入口编号不能重复但可以颠倒也就是说入口编号的顺序不重要各个包括的出现次序可任意例如的分句中也可以选择性的加花括号不过要注意的是如果需要在语句中定义变量花括号是必须要加的例如循环结构有时我们需要做一件事很多遍为了不写过多重复的代码我们需要循环有时循环的次数不是一个常量那么我们无法将代码重复多遍必须使用循环循环初始化判断条件更新循环体流程图例如读入个数循环的三个部分中任何一个部分都可以省略其中若省略了判断条件相当于判断条件永远为真循环判断条件循环体流程图例如验证科拉茨猜想循环循环体判断条件流程图与语句的区别在于语句是先执行循环体再进行判断的枚举排列三种循环的联系循环循环在中没有语句见下文的时候是等价的但是下面一种方法很少用到循环循环在中没有语句的时候这两种方式也也是等价的这三种方式都是永远循环下去可以使用见下文退出可以看出三种循环可以彼此代替但一般来说循环的选用遵守以下原则循环过程中有个固定的增加步骤最常见的是枚举时使用循环只确定循环的终止条件时使用循环使用循环时若要先执行循环体再进行判断使用循环一般很少用到常用场景是用户输入与语句语句的作用是退出循环语句的作用是跳过循环体的余下部分下面以语句在语句中的使用为例等价于与语句均可在三种循环语句的循环体中使用一般来说与语句用于让代码的逻辑更加清晰例如逻辑较为不清晰大括号层次复杂逻辑更加清晰大括号层次简单明了语句判断条件复杂没有体现枚举的本质语句用于枚举用于到何时为止语句重复顺序不自然没有重复语句顺序自然高级数据类型数组数组是存放相同类型对象的容器数组中存放的对象没有名字而是要通过其所在的位置访问数组的大小是固定的不能随意改变数组的长度定义数组数组的声明形如其中是数组的名字是数组中元素的个数在编译时应该是已知的也就是说应该是一个整型的常量表达式错误不是常量表达式正确是一个长度为的数组不能将一个数组直接赋值给另一个数组错误错误应该尽量将较大的数组定义为全局变量因为局部变量会被创建在栈区中过大大于栈的大小的数组会爆栈进而导致如果将数组声明在全局作用域中就会在静态区中创建数组访问数组元素可以通过下标运算符来访问数组内元素数组的索引即方括号中的值从开始以一个包含个元素的数组为例它的索引为到而非到但在程序设计中为了使用方便我们通常会将数组开大一点不使用数组的第一个元素从下标开始访问数组元素例从标准输入中读取一个整数再读取个数存入数组中其中数组的下标范围是例接例求和数组中的元素并输出和满足数组中所有元素的和小于等于越界访问下标数组的下标应当满足如果下标越界则会产生不可预料的后果如段错误或者修改预期以外的变量多维数组多维数组的实质是数组的数组即外层数组的元素是数组一个二维数组需要两个维度来定义数组的长度和数组内元素的长度访问二维数组时需要写出两个索引一个长度为的数组它的元素是元素为的长度为的的数组访问二维数组我们经常使用嵌套的循环来处理二维数组例从标准输入中读取两个数和分别表示黑白图片的高与宽满足对于接下来的行数据每行有用空格分隔开的个数代表这一位置的亮度值现在我们读取这张图片并将其存入二维数组中类似地你可以定义三维四维以及更高维的数组结构体结构体可以看做是一系列称为成员元素的组合体可以看做是自定义的数据类型本节描述的不同于中在中被扩展为类似的类说明符定义结构体上例中定义了一个名为的结构体两个成员元素类型都为在后定义了数据类型为的常量变量变量数组指针对于某种已经存在的类型都可以使用这里的方法进行定义常量变量指针数组等访问修改成员元素可以使用变量名成员元素名进行访问如输出的成员也可以使用指针名成员元素名或者使用指针名成员元素名进行访问如将结构体指针指向的结构体的成员元素赋值为或者结构体的意义首先条条大路通罗马可以不使用结构体达到相同的效果结构体的意义在于它能够显式地将成员元素在程序设计比赛中通常是变量捆绑在一起如本例中的结构体便将放在了一起定义这个结构体的实际意义是表示一件物品的重量与价值这样的好处边是限制了成员元素的使用想象一下如果不使用结构体而使用两个数组很容易写混淆但如果使用结构体能够减轻出现使用变量错误的几率并且不同的结构体结构体类型如这个结构体或者不同的结构体变量结构体的实例如上方的数组可以拥有相同名字的成员元素如同名的成员元素相互独立拥有独自的内存比如说修改不会影响的值这样的好处是可以使用尽可能相同或者相近的变量去描述一个物品比如说里有这个成员变量我们还可以定义一个结构体同时也拥有这个成员如果不使用结构体或许我们就需要定义等不同名称的数组来区分如果想要更详细的描述一种事物还可以定义成员函数中的类就是为此而生的结构体的弊端为了访问内存的效率更高编译器在处理结构体中成员的实际存储情况时可能会将成员对齐在一定的字节位置也就意味着结构体中有空余的地方因此该结构体所占用的空间可能大于其中所有成员所占空间的总和指针变量的地址指针在程序中我们的数据都有其存储的地址在程序每次的实际运行过程中变量在物理内存中的存储位置不尽相同不过我们仍能够在编程时通过一定的语句来取得数据在内存中的地址地址也是数据存放地址所用的变量类型有一个特殊的名字叫做指针变量有时也简称做指针指针变量的大小与机器的位数有关位机器上的指针变量通常是字节位机器上的指针变量通常是字节地址只是一个刻度一般的数据为了针对不同类型的数据指针变量也有不同的类型比如可以有类型的指针变量其中存储的地址即指针变量存储的数值对应一块大小为位的空间的起始地址有类型的指针变量其中存储的地址对应一块位的空间的起始地址事实上用户也可以声明指向指针变量的指针变量假如用户自定义了一个结构体则类型的指针变量对应着一块的空间指针的声明与使用中指针变量的类型为类型名后加上一个星号比如类型的指针变量的类型名即为我们可以使用符号取得一个变量的地址要想访问指针变量地址所对应的空间又称指针所指向的空间需要对指针变量进行解引用使用符号对结构体变量也是类似如果要访问指针指向的结构中的成员需要先对指针进行解引用再使用成员关系运算符不过更推荐使用箭头运算符这一更简便的写法指针的偏移指针变量也可以和整数进行加减操作对于型指针每加递增其指向的地址偏移位即个字节若加则指向的地址偏移位同理对于型指针每次递增其指向的地址偏移位即个字节使用指针偏移访问数组我们前面说过数组是一块连续的存储空间而在中直接使用数组名得到的是数组的起始地址指向指向指向当通过指针访问数组中的元素时往往需要用到指针的偏移换句话说即通过一个基地址数组起始的地址加上偏移量来访问我们常用运算符来访问数组中某一指定偏移量处的元素比如或者这种写法和对指针进行运算后再引用是等价的即和是等价的两种写法空指针在之前和一样使用宏表示空指针常量中的实现一般如下前空指针和整数的混用在中会导致许多问题比如函数重载在调用时实际调用的函数的类型是而不是为了解决这些问题引入了关键字作为空指针常量规定可以隐式转换为任何指针类型这种转换结果是该类型的空指针值的类型为称作空指针类型可能的实现如下另外起宏的实现也被修改为了起指针的进阶使用使用指针使得程序编写者可以操作程序运行时中各处的数据而不必局限于作用域指针类型参数的使用在中调用函数过程时使用的参数均以拷贝的形式传入子过程中引用除外会在后续介绍默认情况下函数仅能通过返回值将结果返回到调用处但是如果某个函数希望修改其外部的数据或者某个结构体类的数据量较为庞大不宜进行拷贝这时则可以通过向其传入外部数据的地址便得以在其中访问甚至修改外部数据下面的方法通过接收两个型的指针在函数中使用中间变量完成对两个型变量值的交换调用后函数中变量的值变为变量的值变为中引入了引用的概念相对于指针来说更易用也更安全动态实例化除此之外程序编写时往往会涉及到动态内存分配即程序会在运行时向操作系统动态地申请或归还存放数据所需的内存当程序通过调用操作系统接口申请内存时操作系统将返回程序所申请空间的地址要使用这块空间我们需要将这块空间的地址存储在指针变量中在中我们使用运算符来获取一块内存使用运算符释放某指针所指向的空间上面的语句使用运算符向操作系统申请了一块大小的空间将其中的值初始化为并声明了一个型的指针指向这块空间同理也可以使用开辟新的对象如上表达式将尝试开辟一块对应大小的空间并尝试在这块空间上构造这一对象并返回这一空间的地址运算符可以用来初始化没有构造函数的结构除此之外使用运算符可以使得变量的初始化形式变得统一详见列表初始化起需要注意当使用申请的内存不再使用时需要使用释放这块空间不能对一块内存释放两次或以上而对空指针使用操作是合法的动态创建数组也可以使用运算符创建数组这时运算符会返回数组的首地址也就是数组第一个元素的地址我们可以用对应类型的指针存储这个地址释放时则需要使用运算符数组中元素的存储是连续的即指向的是的后继元素二维数组在存放矩阵形式的数据时可能会用到二维数组这样的数据类型从语义上来讲二维数组是一个数组的数组而计算机内存可以视作一个很长的一维数组要在计算机内存中存放一个二维数组便有连续与否的说法所谓连续即二维数组的任意一行的末尾与下一行的起始在物理地址上是毗邻的换言之整个二维数组可以视作一个一维数组反之则二者在物理上不一定相邻对于连续的二维数组可以仅使用一个循环借由一个不断递增的指针即可遍历数组中的所有数据而对于非连续的二维数组由于每一行不连续则需要先取得某一行首的地址再访问这一行中的元素这种按照行存储数据的方式称为行优先存储相对的也可以按照列存储数据由于计算机内存访问的特性一般来说访问连续的数据会得到更高的效率因此需要按照数据可能的使用方式选择行优先或列优先的存储方式动态创建二维数组在中我们可以使用类似下面这样的语句声明一个行列的二维数组其空间在物理上是连续的这种声明方式要求和为在编译期即可确定的常量表达式在中数组的第一个元素下标为因此这样的式子代表二维数组中第行的第个元素我们也称这个元素的下标为不过实际使用中二维数组的大小可能不是固定的需要动态内存分配常见的方式是声明一个长度为的一维数组并通过下标访问二维数组中下标为的元素这种方法可以保证二维数组是连续的此外亦可以根据数组的数组这一概念来进行内存的获取与使用对于一个存放的若干数组的数组实际上为一个存放的若干数组的首地址的数组也就是一个存放若干指针变量的数组我们需要一个变量来存放这个数组的数组的首地址也就是一个指针的地址这个变量便是一个指向指针的指针有时也称作二重指针如接着我们需要为每一个数组申请空间至此我们便完成了内存的获取而对于这样获得的内存的释放则需要进行一个逆向的操作即先释放每一个数组再释放存储这些数组首地址的数组如需要注意这样获得的二维数组不能保证其空间是连续的还有一种方式需要使用到指向数组的指针这种方式获得到的也是连续的内存但是可以直接使用的形式获得到数组的第行的首地址因此使用的形式即可访问到下标为的元素由于指向数组的指针也是一种确定的数据类型因此除数组的第一维外其他维度的长度均须为一个能在编译器确定的常量不然编译器将无法翻译如这样的表达式为指向数组的指针指向函数的指针关于函数的介绍请参见本文函数章节简单地说要调用一个函数需要知晓该函数的参数类型个数以及返回值类型这些也统一称作接口类型可以通过函数指针调用函数有时候若干个函数的接口类型是相同的使用函数指针可以根据程序的运行动态地选择需要调用的函数换句话说可以在不修改一个函数的情况下仅通过修改向其传入的参数函数指针使得该函数的行为发生变化假设我们有若干针对类型的二元运算函数则函数的参数为个返回值亦为下边是一个使用了函数指针的例子可以使用关键字声明函数指针的类型这样我们就可以在之后使用这种类型即指向参数为个返回值亦为的函数的指针函数函数的声明编程中的函数一般是若干语句的集合我们也可以将其称作子过程在编程中如果有一些重复的过程我们可以将其提取出来形成一个函数函数可以接收若干值这叫做函数的参数函数也可以返回某个值这叫做函数的返回值声明一个函数我们需要返回值类型函数的名称以及参数列表返回值类型函数的名称参数列表如上图我们声明了一个名为的函数它需要接收两个类型的参数返回值类型也为可以认为这个函数将会对传入的两个整数进行一些操作并且返回一个同样类型的结果实现函数编写函数的定义只有函数的声明还不够他只能让我们在调用时能够得知函数的接口类型即接收什么数据返回什么数据但其缺乏具体的内部实现也就是函数的定义我们可以在声明之后的其他地方编写代码实现这个函数也可以在另外的文件中实现但是需要将分别编译后的文件在链接时一并给出如果函数有返回值则需要通过语句将值返回给调用方函数一旦执行到语句则直接结束当前函数不再执行后续的语句声明定义这条语句不会被执行在定义时我们给函数的参数列表的变量起了名字这样我们便可以在函数定义中使用这些变量了如果是同一个文件中我们也可以直接将声明和定义合并在一起换句话说也就是在声明时就完成定义如果函数不需要有返回值则将函数的返回值类型标为如果函数不需要参数则可以将参数列表置空同样无返回值的函数执行到语句也会结束执行这条语句不会被执行函数的调用和变量一样函数需要先被声明才能使用使用函数的行为叫做调用我们可以在任何函数内部调用其他函数包括这个函数自身函数调用自身的行为称为递归在大多数语言中调用函数的写法是函数名称加上一对括号如如果函数需要参数则我们将其需要的参数按顺序填写在括号中以逗号间隔如函数的调用也是一个表达式函数的返回值就是表达式的值函数声明时候写出的参数可以理解为在函数当前次调用的内部可以使用的变量这些变量的值由调用处传入的值初始化看下面这个例子调用前调用调用后在上面的例子中是一次对的调用调用时中的和变量分别由调用处和的值初始化因此在中对变量和的修改并不会影响到调用处的变量的值如果我们需要在函数子过程中修改变量的值则需要采用传引用的方式调用前调用调用后上述代码中我们看到函数参数列表中的后面添加了一个符号这表示对于类型的引用在调用时调用处和变量分别初始化了中两个对类型的引用和在中的和可以理解为调用处和变量的别名即中对和的操作就是对调用处和的操作函数特别的每个程序都需要有一个名为的函数任何程序都将从函数开始运行函数也可以有参数通过函数的参数我们可以获得外界传给这个程序的指令也就是命令行参数以便做出不同的反应下面是一段调用了函数子过程的代码文件操作文件的概念文件是根据特定的目的而收集在一起的有关数据的集合把每一个文件都看成是一个有序的字节流每个文件都是以文件结束标志结束如果要操作某个文件程序应该首先打开该文件每当一个文件被打开后请记得关闭打开的文件该文件就和一个流关联起来这里的流实际上是一个字节序列将文件分为文本文件和二进制文件文本文件就是简单的文本文件重点另外二进制文件就是特殊格式的文件或者可执行代码文件等文件的操作步骤打开文件将文件指针指向文件决定打开文件类型对文件进行读写操作比赛中主要用到的操作其他一些操作暂时不写在使用完文件后关闭文件函数函数简介函数用于将指定输入输出流以指定方式重定向到文件包含于头文件中该函数可以在不改变代码原貌的情况下改变输入输出环境但使用时应当保证流是可靠的函数主要有三种方式读写和附加函数原型参数说明要打开的文件名文件打开的模式表示文件访问的权限文件指针通常使用标准文件流或标准错误输出流返回值文件指针指向被打开文件文件打开格式以只读方式打开文件文件必须存在只允许读入数据常用以读写方式打开文件文件必须存在允许读写数据以只读方式打开二进制文件文件必须存在只允许读入数据以读写方式打开二进制文件文件必须存在允许读写数据以读写方式打开文本文件允许读写数据以只写方式打开文件文件不存在会新建文件否则清空内容只允许写入数据常用以读写方式打开文件文件不存在将新建文件否则清空内容允许读写数据以只写方式打开二进制文件文件不存在将会新建文件否则清空内容只允许写入数据以读写方式打开二进制文件文件不存在将新建文件否则清空内容允许读写数据以只写方式打开文件文件不存在将新建文件写入数据将被附加在文件末尾保留符以读写方式打开文件文件不存在将新建文件写入数据将被附加在文件末尾不保留符以读写方式打开文本文件写入数据将被附加在文件末尾以读写方式打开二进制文件写入数据将被附加在文件末尾使用方法读入文件内容就是读取的文件名要和可执行文件放在同一目录下输出文件内容就是输出文件的文件名和可执行文件在同一目录下关闭标准输入输出流注等函数默认使用将重定向后这些函数将输入输出到被定向的文件模板中间的代码不需要改变直接使用和即可函数选读函数大致与相同函数将打开指定文件并返回打开文件的指针程序设计中不常用到函数原型各项参数含义同可用读写函数基本使用方式定义文件指针的文件输入输出流使用方法读入文件内容就是读取文件的相对位置或绝对位置输出到文件就是输出文件的相对位置或绝对位置关闭标准输入输出流模板两个类型都在命名空间里中间的代码改变为为即可参考资料复合类型包括数组类型引用类型指针类型类类型函数类型等由于本文是面向初学者的故不在本文做具体介绍具体请参阅类型详见值类别不包含宽字符类型位域和枚举类型详见整型转换定义一个变量时除了类型说明符之外还可以包含其他说明符详见声明更通用的方式是使用第维的说法对于行优先的存储形式数组的第一维长度为第二维长度为实际上数据在内存中都可以视作线性存放的因此在一定的规则下通过动态开辟一维数组的空间即可在其上存储维的数组",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-08-24 21:23:59",postMainColor:"#b0cfec"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:(e,t,a)=>{if(0===a)return;const o={value:t,expiry:Date.now()+864e5*a};localStorage.setItem(e,JSON.stringify(o))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const a=JSON.parse(t);if(!(Date.now()>a.expiry))return a.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((a,o)=>{const c=document.createElement("script");c.src=e,c.async=!0,c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},Object.keys(t).forEach((e=>{c.setAttribute(e,t[e])})),document.head.appendChild(c)})),e.getCSS=(e,t=!1)=>new Promise(((a,o)=>{const c=document.createElement("link");c.rel="stylesheet",c.href=e,t&&(c.id=t),c.onerror=o,c.onload=c.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(c.onload=c.onreadystatechange=null,a())},document.head.appendChild(c)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#18171d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#f7f9fe")};const t=saveToLocal.get("theme"),a=window.matchMedia("(prefers-color-scheme: dark)").matches,o=window.matchMedia("(prefers-color-scheme: light)").matches,c=window.matchMedia("(prefers-color-scheme: no-preference)").matches,n=!a&&!o&&!c;if(void 0===t){if(o)activateLightMode();else if(a)activateDarkMode();else if(c||n){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((e=>{void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const d=saveToLocal.get("aside-status");void 0!==d&&("hide"===d?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><meta name="referrer" content="never"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/highlight-one-dark.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="alternate" href="/atom.xml" title="小嗷犬" type="application/atom+xml"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avatar/2.png"><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()})),setTimeout((function(){preloader.endLoading()}),1e4),document.addEventListener("pjax:send",(()=>{preloader.initLoading()})),document.addEventListener("pjax:complete",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"><script async src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://marquis.eu.org/" title="个人主页"><img class="back-menu-item-icon" src="/img/avatar/1.png" alt="个人主页"><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" href="https://blog.marquis.eu.org/" title="个人博客"><img class="back-menu-item-icon" src="/img/avatar/2.png" alt="个人博客"><span class="back-menu-item-text">个人博客</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小嗷犬</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="fas fa-chart-bar faa-tada"></i> <span>统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8947107806&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i> <span>相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/favorites/"><i class="fas fa-star faa-tada"></i> <span>收藏夹</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size:.9em"></i> <span>装备栏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i> <span>友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i> <span>关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size:.9em"></i> <span>闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i> <span>随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i> <span>搜索</span></a></div><input id="center-console" type="checkbox"><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole()"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/reward/wechat.png" target="_blank"><img class="post-qr-code-img" alt="WeChat Pay" src="/img/reward/wechat.png"></a><div class="post-qr-code-desc">WeChat Pay</div></li><li class="reward-item"><a href="/img/reward/alipay.png" target="_blank"><img class="post-qr-code-img" alt="Alipay" src="/img/reward/alipay.png"></a><div class="post-qr-code-desc">Alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title">最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size:1.05rem">C<sup>1</sup></a><a href="/tags/CPP/" style="font-size:1.05rem">CPP<sup>5</sup></a><a href="/tags/LaTeX/" style="font-size:1.05rem">LaTeX<sup>4</sup></a><a href="/tags/Linux/" style="font-size:1.05rem">Linux<sup>1</sup></a><a href="/tags/MATLAB/" style="font-size:1.05rem;font-weight:500;color:var(--anzhiyu-lighttext)">MATLAB<sup>28</sup></a><a href="/tags/Markdown/" style="font-size:1.05rem">Markdown<sup>5</sup></a><a href="/tags/Python/" style="font-size:1.05rem;font-weight:500;color:var(--anzhiyu-lighttext)">Python<sup>43</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size:1.05rem">前端<sup>1</sup></a><a href="/tags/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB/" style="font-size:1.05rem">动作识别<sup>2</sup></a><a href="/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/" style="font-size:1.05rem">多任务<sup>1</sup></a><a href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/" style="font-size:1.05rem">多模态<sup>41</sup></a><a href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" style="font-size:1.05rem">大模型<sup>44</sup></a><a href="/tags/%E5%B0%91%E6%A0%B7%E6%9C%AC/" style="font-size:1.05rem">少样本<sup>4</sup></a><a href="/tags/%E5%BE%AE%E8%B0%83/" style="font-size:1.05rem">微调<sup>11</sup></a><a href="/tags/%E6%89%8B%E8%AF%AD%E7%BF%BB%E8%AF%91/" style="font-size:1.05rem">手语翻译<sup>21</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:1.05rem">操作系统<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" style="font-size:1.05rem">数学建模<sup>20</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size:1.05rem">数据分析<sup>5</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/" style="font-size:1.05rem">数据可视化<sup>2</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size:1.05rem">机器学习<sup>8</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size:1.05rem">深度学习<sup>19</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size:1.05rem">爬虫<sup>5</sup></a><a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" style="font-size:1.05rem">程序设计<sup>11</sup></a><a href="/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" style="font-size:1.05rem">论文笔记<sup>66</sup></a></div></div><hr></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多"><i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">21</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">22</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/CPP/" tabindex="-1" itemprop="url"><span><i class="anzhiyufont anzhiyu-icon-hashtag"></i> CPP</span></a><a class="article-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" tabindex="-1" itemprop="url"><span><i class="anzhiyufont anzhiyu-icon-hashtag"></i> 程序设计</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C++ 程序设计入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-07-01T15:35:15.000Z" title="发表于 2023-07-01 23:35:15">2023-07-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-08-24T13:23:59.000Z" title="更新于 2023-08-24 21:23:59">2023-08-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">17.3k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" data-flag-title="C++ 程序设计入门"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator"></span><span class="post-meta-position" title="作者IP属地为成都"><i class="anzhiyufont anzhiyu-icon-location-dot"></i> 成都</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/a54c2388/#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s58 18 88 18 58-18 88-18 58 18 88 18v44h-352Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img-blog.csdnimg.cn/53244566b46c41bb95f2a0e463f21bae.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><i class="anzhiyufont anzhiyu-icon-circle-dot" title="朗读摘要"></i><div id="ai-tag">小嗷犬 GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己 🙈</div><div class="ai-btn-item">生成本文简介 👋</div><div class="ai-btn-item">推荐相关文章 📖</div><div class="ai-btn-item">前往主页 🏠</div><div class="ai-btn-item" id="go-tianli-blog">前往爱发电购买</div></div><script data-pjax src="/js/anzhiyu/ai_abstract.js"></script></div><article class="post-content" id="article-container" itemscope itemtype="https://blog.marquis.eu.org/posts/a54c2388/"><header><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url">学习笔记</a><a href="/tags/CPP/" tabindex="-1" itemprop="url">CPP</a><a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" tabindex="-1" itemprop="url">程序设计</a><h1 id="CrawlerTitle" itemprop="name headline">C++ 程序设计入门</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小嗷犬</span><time itemprop="dateCreated datePublished" datetime="2023-07-01T15:35:15.000Z" title="发表于 2023-07-01 23:35:15">2023-07-01</time><time itemprop="dateCreated datePublished" datetime="2023-08-24T13:23:59.000Z" title="更新于 2023-08-24 21:23:59">2023-08-24</time></header><p>程序是算法与数据结构的载体，是计算机用以解决问题的工具。</p><p>而在程序设计比赛中，最主流的语言是 <strong>C++</strong>。</p><p>学习编程是学习程序设计最 <strong>基础</strong> 的部分。</p><h2 id="如何开始">如何开始</h2><h3 id="环境配置">环境配置</h3><p>工欲善其事，必先利其器。</p><h4 id="集成开发环境（IDE）">集成开发环境（IDE）</h4><p>IDE 是 Integrated Development Environment 的缩写，即集成开发环境。它包括了代码编辑器、编译器、调试器等程序从编写到运行的一系列工具。配置较为简单，适合入门玩家。</p><p>在竞赛中最常见的是 <strong>Dev-C++</strong>。Dev-C++ 的优点在于界面简洁友好，安装便捷，支持单文件编译，因此成为了许多入门程序设计选手以及 C++ 语言初学者的首选。</p><p>Dev-C++ 起源于 Colin Laplace 编写的 Bloodshed Dev-C++。该版本自 2005 年 2 月 22 日停止更新。后续又有 <a target="_blank" rel="noopener" href="https://sourceforge.net/projects/orwelldevcpp/">Orwell Dev-C++</a>、<a target="_blank" rel="noopener" href="https://www.embarcadero.com/free-tools/dev-cpp">Embarcadero Dev-C++</a> 等衍生版本。</p><p>以上的 Dev-C++ 分发都被认为是「官方的」。此外，在 2015 年 Orwell Dev-C++ 停止更新后，因为教学需要，一位来自中国的个人开发者 <a target="_blank" rel="noopener" href="https://github.com/royqh1979">royqh1979</a> 决定继续开发他的 Dev-C++ 个人分支，命名为小熊猫 Dev-C++，集成了智能提示和高版本的 MinGW64，非常便于国内的个人使用和学习，项目官网位于 <a target="_blank" rel="noopener" href="https://royqh1979.gitee.io/redpandacpp">小熊猫 Dev-C++</a>，源代码托管于 <a target="_blank" rel="noopener" href="https://github.com/royqh1979/Dev-Cpp">Github</a>。</p><p><img src="/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" data-lazy-src="https://img-blog.csdnimg.cn/658b029954744cfcace94b2d51344d07.png" alt="Dev-C++ 的图标"></p><p>小熊猫官网也提供了相应的 <a target="_blank" rel="noopener" href="https://royqh1979.gitee.io/redpandacpp/docsy/docs/tutorials/basictutorial/">小熊猫 Dev-C++ 入门教程</a>，本文推荐使用小熊猫 Dev-C++ 来进行 C++ 的学习。</p><h4 id="编译器">编译器</h4><p>除了使用 IDE 之外，我们也可以使用编译器来编译我们的代码。这么做的好处是可以分离程序的编写和编译过程，使得我们可以选择更加适合自己的代码编辑器；同时，也可以使用命令行更灵活地编译我们的代码。</p><p>常见的编译器有 GCC、Clang、MSVC 等。</p><p>配置相较于 IDE 来说稍微复杂一些，适合已经对 C++ 有一定理解的玩家。</p><hr><h3 id="第一个-C-程序">第一个 C++ 程序</h3><p>通过编写一个简单的示例程序来开始我们的 C++ 之旅吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  <span class="hljs-comment">// 引用输入输出流头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">// 使用标准命名空间</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;                                    <span class="hljs-comment">// 定义 main 函数</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello, SWUFE!&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出 Hello, SWUFE! 并换行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                        <span class="hljs-comment">// 返回 0 表示程序正常结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与它相对应的 C 语言版本如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> <span class="hljs-comment">// 引用标准输入输出头文件</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;                              <span class="hljs-comment">// 定义 main 函数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, SWUFE!\n&quot;</span>); <span class="hljs-comment">// 输出 Hello, SWUFE! 并换行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 返回 0 表示程序正常结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：本文的 C 语言代码仅做参考，C++ 基本上兼容 C 语言，并且拥有许多新的功能，可以让选手在赛场上事半功倍。</p><hr><h2 id="C-语法基础">C++ 语法基础</h2><h3 id="代码框架">代码框架</h3><p>如果你不想深究背后的原理，初学时可以直接将这个「框架」背下来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// do something...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="什么是-include">什么是 include</h4><p><code>#include</code> 其实是一个预处理命令，意思为将一个文件<strong>放</strong>在这条语句处，被<strong>放</strong>的文件被称为头文件。也就是说，在编译时，编译器会<strong>复制</strong>头文件 <code>iostream</code> 中的内容，<strong>粘贴</strong>到 <code>#include &lt;iostream&gt;</code> 这条语句处。这样，你就可以使用 <code>iostream</code> 中提供的 <code>std::cin</code>、<code>std::cout</code>、<code>std::endl</code> 等对象了。</p><p>如果你学过 C 语言，你会发现目前我们接触的 C++ 中的头文件一般都不带 <code>.h</code> 后缀，而那些 C 语言中的头文件 <code>xx.h</code> 都变成了 <code>cxx</code>，如 <code>stdio.h</code> 变成了 <code>cstdio</code>。因为 C++ 为了和 C 保持兼容，都直接使用了 C 语言中的头文件，为了区分 C++ 的头文件和 C 的头文件，使用了 <code>c</code> 前缀。</p><p>通常情况下，我们只需要 <code>#include</code> 自己所需的头文件，比如上文的 <code>iostream</code> 和 <code>cstdio</code>，引入它们就可以使用 <code>std::cin</code>、<code>std::cout</code>、<code>scanf</code>、<code>printf</code> 来进行输入输出了。</p><h4 id="什么是-namespace">什么是 namespace</h4><p><code>namespace</code> 是命名空间的意思。C++ 的命名空间机制可以用来解决复杂项目中名字冲突的问题。</p><p>举个例子：C++ 标准库的所有内容均定义在 <code>std</code> 命名空间中，如果你定义了一个叫 <code>cin</code> 的变量，则可以通过 <code>cin</code> 来访问你定义的 <code>cin</code> 变量，通过 <code>std::cin</code> 访问标准库的 <code>cin</code> 对象，而不用担心产生冲突。</p><p>如果你不想每次都写 <code>std::</code>，可以使用 <code>using namespace std;</code> 来引入 <code>std</code> 命名空间，这样你就可以直接使用 <code>cin</code>、<code>cout</code>、<code>endl</code> 等对象了。</p><h4 id="什么是-main-函数">什么是 main 函数</h4><p>可以理解为程序运行时就会执行 <code>main()</code> 中的代码。</p><p>实际上，<code>main</code> 函数是由系统或外部程序调用的。如，你在命令行中调用了你的程序，也就是调用了你程序中的 <code>main</code> 函数。</p><p>最后的 <code>return 0;</code> 表示程序运行成功。默认情况下，程序结束时返回 0 表示一切正常，否则返回值表示错误代码。这个值返回给谁呢？其实就是调用你写的程序的系统或外部程序，它会在你的程序结束时接收到这个返回值。如果不写 <code>return</code> 语句的话，程序正常结束默认返回值也是 0。</p><p>在 C 或 C++ 中，程序的返回值不为 0 会导致运行时错误（RE）。</p><h3 id="注释">注释</h3><p>在 C++ 代码中，注释有两种写法：</p><ul><li><strong>单行注释：</strong><code>//</code></li><li><strong>多行注释：</strong><code>/* */</code></li></ul><p>程序运行没有影响，可以用来解释程序的意思，还可以在让某段代码不执行（但是依然保留在源文件里）。</p><p>在工程开发中，注释可以便于日后维护、他人阅读。</p><p>在程序设计比赛中，很少有人写大段的注释，但注释可以便于在写代码的时候理清思路，或者便于日后复习。而且，如果要写题解、教程的话，适量的注释可以便于读者阅读，理解代码的意图。</p><p>因此，<strong>写注释是一个好习惯</strong>。</p><h3 id="输入与输出">输入与输出</h3><h4 id="cin-与-cout">cin 与 cout</h4><p>在 C++ 中，我们可以使用 <code>cin</code> 和 <code>cout</code> 来进行输入输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x, y;          <span class="hljs-comment">// 定义两个 int 类型的变量 x 和 y</span><br>    cin &gt;&gt; x &gt;&gt; y;     <span class="hljs-comment">// 输入 x 和 y</span><br>    cout &lt;&lt; y &lt;&lt; endl  <span class="hljs-comment">// 输出 y 换行</span><br>         &lt;&lt; x &lt;&lt; endl; <span class="hljs-comment">// 输出 x 换行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面程序中，<code>cin</code> 和 <code>cout</code> 分别是输入流和输出流的对象，<code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> 分别是输入运算符和输出运算符。</p><p>如何理解输入输出流呢？我们可以把数据流想象成水流，<code>cin</code> 是一个水龙头，<code>cout</code> 是一个排水口，变量 <code>x</code> 和 <code>y</code> 是两个容器，<code>&gt;&gt;</code> 和 <code>&lt;&lt;</code> 是连接水龙头和容器、排水口和容器的管道。<code>cin &gt;&gt; x</code> 的意思就是将水龙头的水流输入到容器 <code>x</code> 中，<code>cout &lt;&lt; y</code> 的意思就是将容器 <code>y</code> 中的水流输出到排水口，运算符的方向总是指向数据流的方向。</p><p>事实上，上述的比喻并不严谨，因为变量是有多种类型的，这意味着“容器”也有多种类型，自然数据流中就不会只有水这一种“液体”。</p><p>关于变量的知识，我们将在后面的章节中进行介绍。</p><h4 id="scanf-与-printf">scanf 与 printf</h4><p><code>scanf</code> 与 <code>printf</code> 其实是 C 语言提供的函数。大多数情况下，它们的速度比 <code>cin</code> 和 <code>cout</code> 更快，并且能够方便地控制输入输出格式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);    <span class="hljs-comment">// 输入 x 和 y</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n%d\n&quot;</span>, y, x); <span class="hljs-comment">// 输出 y 换行再输出 x 换行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 这段代码与相同功能的 C 语言代码只有头文件的差别</span><br></code></pre></td></tr></table></figure><p>其中，<code>%d</code> 表示读入/输出的变量是一个有符号整型（<code>int</code> 型）的变量。这样的符号称为格式控制符，用来控制输入输出的格式。</p><p>常用的控制符有：</p><table><thead><tr><th style="text-align:left">控制符</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>%s</code></td><td style="text-align:left">字符串</td></tr><tr><td style="text-align:left"><code>%c</code></td><td style="text-align:left">字符</td></tr><tr><td style="text-align:left"><code>%d</code></td><td style="text-align:left">有符号十进制整数 (<code>int</code>)</td></tr><tr><td style="text-align:left"><code>%lld</code> 或 <code>%I64d</code> (依系统而定)</td><td style="text-align:left">长整型 (<code>long long</code>)</td></tr><tr><td style="text-align:left"><code>%lf</code></td><td style="text-align:left">双精度浮点数 (<code>double</code>)</td></tr><tr><td style="text-align:left"><code>%u</code></td><td style="text-align:left">无符号十进制整数 (<code>unsigned int</code>)</td></tr><tr><td style="text-align:left"><code>%llu</code> 或 <code>%I64u</code> (依系统而定)</td><td style="text-align:left">无符号长整型 (<code>unsigned long long</code>)</td></tr></tbody></table><p>格式控制符除了能表示类型外，还能够控制格式，常用的有：</p><table><thead><tr><th>控制符</th><th>说明</th></tr></thead><tbody><tr><td><code>%1d</code></td><td>长度为 1 的整型。<br>在读入时，即使没有空格也可以逐位读入数字。<br>在输出时，若指定的长度大于数字的位数，就会在数字前用空格填充。若指定的长度小于数字的位数，就没有效果。</td></tr><tr><td><code>%.6lf</code></td><td>用于输出，保留 6 位小数。</td></tr></tbody></table><p>上面两个格式控制符相应位置填入不同数字就会有不同的效果，如 <code>%.3lf</code> 表示保留 3 位小数。</p><h3 id="扩展内容">扩展内容</h3><h4 id="endl-与-‘-n’">endl 与 ‘\n’</h4><p><code>endl</code> 是 C++ 中的一个 IO 操作符，它的作用是插入一个换行符，并刷新输出缓冲区。<code>cout &lt;&lt; endl;</code> 事实上等价于 <code>cout &lt;&lt; '\n' &lt;&lt; flush;</code>。</p><p>大部分情况下 <code>cout &lt;&lt; '\n'</code> 和 <code>cout &lt;&lt; endl</code> 运行起来并无明显区别，除非题目要求你输出之后立即刷新缓冲区（<s>说的就是你，交互题！</s>）。</p><h4 id="C-中的空白字符">C++ 中的空白字符</h4><p>在 C++ 中，所有空白字符（空格、制表符、换行），多个或是单个，都被视作是一样的。（当然，引号中视作字符串的一部分的不算。）</p><p>因此，你可以自由地使用任何代码风格（除了行内注释、字符串字面量与预处理命令必须在单行内），例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br> <span class="hljs-function"><span class="hljs-type">int</span> </span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span><span class="hljs-comment">/**/</span>x, y;  std::cin<br>&gt;&gt; x &gt;&gt;y;<br>                std::cout &lt;&lt;<br>          y  &lt;&lt;std::endl   <br>     &lt;&lt; x            &lt;&lt; std::endl<br><br>          ;<br><br>    <span class="hljs-keyword">return</span>       <span class="hljs-number">0</span>;     &#125;<br></code></pre></td></tr></table></figure><p>这段程序和上文写的程序一样，能够完成相同的事情，读入两个整数，然后先输出第二个整数，再输出第一个整数，每输出一个整数换一行。</p><p>当然，这么做是<strong>不被推荐</strong>的。</p><h4 id="define-命令">define 命令</h4><p><code>#define</code> 是一种预处理命令，用于定义宏，本质上是文本替换。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> n 666</span><br><br><span class="hljs-comment">// n 不是变量，而是编译器会将代码中所有 n 文本替换为 666，但是作为标识符一部分的</span><br><span class="hljs-comment">// n 的就不会被替换，如 fn 不会被替换成 f666，同样，字符串内的也不会被替换</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; n; <span class="hljs-comment">// 输出 666</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>宏可以带参数，带参数的宏可以像函数一样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sum(x, y) ((x) + (y))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> square(x) ((x) * (x))</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">2</span> * <span class="hljs-built_in">sum</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出 3 16</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是带参数的宏和函数有区别。因为宏是文本替换，所以会引发许多问题。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sum(x, y) x + y</span><br><span class="hljs-comment">// 这里应当为 #define sum(x, y) ((x) + (y))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> square(x) ((x) * (x))</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">2</span> * <span class="hljs-built_in">sum</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 输出为 3 11，因为 #define 是文本替换，后面的语句被替换为了 2* 3 + 5</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    std::cout &lt;&lt; <span class="hljs-built_in">square</span>(++i) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i;<br>    <span class="hljs-comment">// 输出未定义，因为 ++i 被执行了两遍</span><br>    <span class="hljs-comment">// 而同一个语句中多次修改同一个变量是未定义行为（有例外）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此，使用 <code>#define</code> 是有风险的，应<strong>谨慎使用</strong>。</p><hr><h2 id="变量">变量</h2><h3 id="数据类型">数据类型</h3><p>C++ 的类型系统主要由如下几部分组成：</p><ul><li>基础类型（括号内为代表关键词/代表类型）<ul><li>无类型/<code>void</code> 型 (<code>void</code>)</li><li>（C++11 起）空指针类型 (<code>std::nullptr_t</code>)</li><li>算术类型<ul><li>整数类型 (<code>int</code>)</li><li>布尔类型/<code>bool</code> 型 (<code>bool</code>)</li><li>字符类型 (<code>char</code>)</li><li>浮点类型 (<code>float</code>, <code>double</code>)</li></ul></li></ul></li><li>复合类型<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li></ul><h4 id="布尔类型">布尔类型</h4><p>一个 <code>bool</code> 类型的变量取值只可能为两种：<code>true</code> 和 <code>false</code>。</p><p>一般情况下，一个 <code>bool</code> 类型变量占有 1 字节（一般情况下，1 字节 = 8 位）的空间。</p><h4 id="整数类型">整数类型</h4><p>用于存储整数，最基础的整数类型是 <code>int</code>。</p><p>整数类型一般按位宽有 5 个梯度：<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>。</p><p>C++ 标准保证 <code>1 == sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code>，但对于每种类型的位宽并没有做出具体的规定。</p><p>对于 <code>int</code> 关键字，可以使用如下修饰关键字进行修饰：</p><ul><li>符号性<ul><li><code>signed</code>：有符号的（默认）</li><li><code>unsigned</code>：无符号的</li></ul></li><li>大小<ul><li><code>short</code>：短整型</li><li><code>long</code>：长整型</li><li><code>long long</code>：长长整型</li></ul></li></ul><p>下表给出了各个类型的等价形式和位宽：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">等价形式</th><th style="text-align:center">位宽（C++ 标准）</th><th style="text-align:center">位宽（常见）</th></tr></thead><tbody><tr><td style="text-align:left"><code>signed char</code></td><td style="text-align:left"><code>signed char</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">8</span></span></span></span></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>unsigned char</code></td><td style="text-align:left"><code>unsigned char</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">8</span></span></span></span></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><code>short</code>, <code>short int</code>, <code>signed short</code>, <code>signed short int</code></td><td style="text-align:left"><code>short int</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">\geq 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">16</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">16</span></span></span></span></td></tr><tr><td style="text-align:left"><code>unsigned short</code>, <code>unsigned short int</code></td><td style="text-align:left"><code>unsigned short int</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">\geq 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">16</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn></mrow><annotation encoding="application/x-tex">16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">16</span></span></span></span></td></tr><tr><td style="text-align:left"><code>int</code>, <code>signed</code>, <code>signed int</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">\geq 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">16</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">32</span></span></span></span></td></tr><tr><td style="text-align:left"><code>unsigned</code>, <code>unsigned int</code></td><td style="text-align:left"><code>unsigned int</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">\geq 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">16</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">32</span></span></span></span></td></tr><tr><td style="text-align:left"><code>long</code>, <code>long int</code>, <code>signed long</code>, <code>signed long int</code></td><td style="text-align:left"><code>long int</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">\geq 32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">32</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">32</span></span></span></span></td></tr><tr><td style="text-align:left"><code>unsigned long</code>, <code>unsigned long int</code></td><td style="text-align:left"><code>unsigned long int</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">\geq 32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">32</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">32</span></span></span></span></td></tr><tr><td style="text-align:left"><code>long long</code>, <code>long long int</code>, <code>signed long long</code>, <code>signed long long int</code></td><td style="text-align:left"><code>long long int</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">\geq 64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">64</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">64</span></span></span></span></td></tr><tr><td style="text-align:left"><code>unsigned long long</code>, <code>unsigned long long int</code></td><td style="text-align:left"><code>unsigned long long int</code></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>64</mn></mrow><annotation encoding="application/x-tex">\geq 64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">64</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">64</span></span></span></span></td></tr></tbody></table><p>对于整数类型，当位宽为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">x</span></span></span></span> 时，有符号类型的表示范围为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>∼</mo><msup><mn>2</mn><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2^{x-1} \sim 2^{x-1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8974em;vertical-align:-.0833em"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8974em;vertical-align:-.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span>，无符号类型的表示范围为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><msup><mn>2</mn><mi>x</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \sim 2^x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7477em;vertical-align:-.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.6644em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span>。</p><p>程序设计中最常用的两个整数类型是 <code>int</code> 和 <code>long long</code>。</p><h4 id="字符类型">字符类型</h4><p>分为「窄字符类型」和「宽字符类型」，由于程序设计竞赛几乎不会用到宽字符类型，故此处仅介绍窄字符类型。</p><p>窄字符型位数一般为 8 位，实际上底层存储方式仍然是整数，一般通过 <a target="_blank" rel="noopener" href="https://www.asciitable.com/">ASCII 编码</a> 实现字符与整数的一一对应，有如下三种：</p><ul><li><code>signed char</code>：有符号字符表示的类型，表示范围在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>128</mn><mo>∼</mo><mn>127</mn></mrow><annotation encoding="application/x-tex">-128 \sim 127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">−</span><span class="mord">128</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">127</span></span></span></span> 之间。</li><li><code>unsigned char</code>：无符号字符表示的类型，表示范围在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>∼</mo><mn>255</mn></mrow><annotation encoding="application/x-tex">0 \sim 255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">255</span></span></span></span> 之间。</li><li><code>char</code>：有符号或无符号字符表示的类型，具体由编译器决定。</li></ul><p>事实上，只有 <code>char</code> 类型的变量才应该用于表示字符，<code>signed char</code> 和 <code>unsigned char</code> 类型通常被视为整数类型。</p><h4 id="浮点类型">浮点类型</h4><p>用于存储「实数」（注意并不是严格意义上的实数，而是实数在一定规则下的近似），包括以下三种：</p><ul><li><code>float</code>：单精度浮点类型。如果支持就会匹配 IEEE-754 binary32 格式。</li><li><code>double</code>：双精度浮点类型。如果支持就会匹配 IEEE-754 binary64 格式。</li><li><code>long double</code>：扩展精度浮点类型。如果支持就会匹配 IEEE-754 binary128 格式，否则如果支持就会匹配 IEEE-754 binary64 扩展格式，否则匹配某种精度优于 binary64 而值域至少和 binary64 一样好的非 IEEE-754 扩展浮点格式，否则匹配 IEEE-754 binary64 格式。</li></ul><table><thead><tr><th style="text-align:left">浮点格式</th><th style="text-align:center">位宽</th><th style="text-align:center">最大正数</th><th style="text-align:center">精度位数</th></tr></thead><tbody><tr><td style="text-align:left">IEEE-754 binary32 格式</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>32</mn></mrow><annotation encoding="application/x-tex">32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">32</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3.4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>38</mn></msup></mrow><annotation encoding="application/x-tex">3.4 \times 10^{38}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">3.4</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">38</span></span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mo>∼</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">6 \sim 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">6</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">9</span></span></span></span></td></tr><tr><td style="text-align:left">IEEE-754 binary64 格式</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">64</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.8</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>308</mn></msup></mrow><annotation encoding="application/x-tex">1.8 \times 10^{308}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">1.8</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">308</span></span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>15</mn><mo>∼</mo><mn>17</mn></mrow><annotation encoding="application/x-tex">15 \sim 17</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">15</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">17</span></span></span></span></td></tr><tr><td style="text-align:left">IEEE-754 binary64 扩展格式</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>80</mn></mrow><annotation encoding="application/x-tex">\geq 80</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">80</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>1.2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4932</mn></msup></mrow><annotation encoding="application/x-tex">\geq 1.2 \times 10^{4932}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">1.2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4932</span></span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>18</mn><mo>∼</mo><mn>21</mn></mrow><annotation encoding="application/x-tex">\geq 18 \sim 21</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">18</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">21</span></span></span></span></td></tr><tr><td style="text-align:left">IEEE-754 binary128 格式</td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">128</span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mn>1.2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4932</mn></msup></mrow><annotation encoding="application/x-tex">\geq 1.2 \times 10^{4932}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">1.2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4932</span></span></span></span></span></span></span></span></span></span></span></span></td><td style="text-align:center"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>33</mn><mo>∼</mo><mn>36</mn></mrow><annotation encoding="application/x-tex">33 \sim 36</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">33</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">36</span></span></span></span></td></tr></tbody></table><blockquote><p>IEEE-754 浮点格式的最小负数是最大正数的相反数。</p></blockquote><p>因为 <code>float</code> 类型表示范围较小，且精度不高，实际应用中常使用 <code>double</code> 类型表示浮点数。</p><p>除此之外，浮点类型可以支持一些特殊值：</p><ul><li>正负无穷：<code>INFINITY</code> / <code>-INFINITY</code></li><li>负零：<code>-0.0</code>，例如 <code>1.0 / 0.0 == INFINITY</code>，<code>1.0 / -0.0 == -INFINITY</code></li><li>非数 (<code>NaN</code>)：<code>std::nan</code>, <code>NAN</code>, 一般可以由 <code>0.0 / 0.0</code> 之类的运算产生。它与任何值（包括自身）比较都不相等，C++11 后可以 使用 <code>std::isnan</code> 判断一个浮点数是不是 <code>NaN</code></li></ul><h4 id="无类型">无类型</h4><p><code>void</code> 类型为无类型，与上面几种类型不同的是，不能将一个变量声明为 <code>void</code> 类型。但是函数的返回值允许为 <code>void</code> 类型，表示该函数无返回值。</p><h3 id="类型转换">类型转换</h3><p>在一些时候（比如某个函数接受 <code>int</code> 类型的参数，但传入了 <code>double</code> 类型的变量），我们需要将某种类型，转换成另外一种类型。</p><p>C++ 中类型的转换机制较为复杂，这里主要介绍对于基础数据类型的两种转换：数值提升和数值转换。</p><h4 id="数值提升">数值提升</h4><p>数值提升过程中，值本身保持不变，不会产生精度损失。</p><h5 id="整数提升">整数提升</h5><p>小整数类型（如 <code>char</code>）的纯右值<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>可转换成较大整数类型（如 <code>int</code>）的纯右值。</p><p>具体而言，算术运算符不接受小于 <code>int</code> 的类型作为它的实参，而在左值到右值转换后，如果适用就会自动实施整数提升。</p><p>具体地，有如下规则：</p><ul><li>源类型为 <code>signed char</code>、<code>signed short</code> / <code>short</code> 时，可提升为 <code>int</code>。</li><li>源类型为 <code>unsigned char</code>、<code>unsigned short</code> 时，若 <code>int</code> 能保有源类型的值范围，则可提升为 <code>int</code>，否则可提升为 <code>unsigned int</code>。</li><li><code>char</code> 的提升规则取决于其底层类型是 <code>signed char</code> 还是 <code>unsigned char</code>。</li><li><code>bool</code> 类型可转换到 <code>int</code>：<code>false</code> 变为 <code>0</code>，<code>true</code> 变为 <code>1</code>。</li><li>若目标类型的值范围包含源类型，且源类型的值范围不能被 <code>int</code> 和 <code>unsigned int</code> 包含，则源类型可提升为目标类型<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。</li></ul><h5 id="浮点提升">浮点提升</h5><p>位宽较小的浮点数可以提升为位宽较大的浮点数（例如 <code>float</code> 类型的变量和 <code>double</code> 类型的变量进行算术运算时，会将 <code>float</code> 类型变量提升为 <code>double</code> 类型变量），其值不变。</p><h4 id="数值转换">数值转换</h4><p>数值转换过程中，值可能会发生改变，可能会产生精度损失。</p><p><strong>注意</strong>：数值提升优先于数值转换。如 <code>bool-&gt;int</code> 时是数值提升而非数值转换。</p><h5 id="整数转换">整数转换</h5><ul><li>如果目标类型为位宽为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">x</span></span></span></span> 的无符号整数类型，则转换结果是原值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">\bmod 2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mspace" style="margin-right:.0556em"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:.0556em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.6644em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span> 后的结果。<ul><li>若目标类型位宽大于源类型位宽：<ul><li>若源类型为有符号类型，一般情况下需先进行<strong>符号位扩展</strong>再转换。</li><li>若源类型为无符号类型，则需先进行<strong>零扩展</strong>再转换。</li></ul></li><li>若目标类型位宽不大于源类型位宽，则需先<strong>截断</strong>再转换。</li></ul></li><li>如果目标类型为位宽为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">x</span></span></span></span> 的带符号整数类型，则 <strong>一般情况下</strong>，转换结果可以认为是原值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><msup><mn>2</mn><mi>x</mi></msup></mrow><annotation encoding="application/x-tex">\bmod 2^x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mspace" style="margin-right:.0556em"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:.0556em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.6644em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span></span></span></span></span></span></span> 后的结果。</li><li>如果目标类型是 <code>bool</code>，则是 <strong>布尔转换</strong>。</li><li>如果源类型是 <code>bool</code>，则 <code>false</code> 转为对应类型的 <code>0</code>，<code>true</code> 转为对应类型的 <code>1</code>。</li></ul><h5 id="浮点转换">浮点转换</h5><p>位宽较大的浮点数转换为位宽较小的浮点数，会将该数舍入到目标类型下最接近的值。</p><h5 id="浮点整数转换">浮点整数转换</h5><ul><li>浮点数转换为整数时，会舍弃浮点数的全部小数部分。<br>如果目标类型是 <code>bool</code>，则是 <strong>布尔转换</strong>。</li><li>整数转换为浮点数时，会舍入到目标类型下最接近的值。<br>如果该值不能适应到目标类型中，那么行为未定义。<br>如果源类型是 <code>bool</code>，那么 <code>false</code> 转换为 <code>0</code>，而 <code>true</code> 转换为 <code>1</code>。</li></ul><h5 id="布尔转换">布尔转换</h5><p>将其他类型转换为 <code>bool</code> 类型时，零值转换为 <code>false</code>，非零值转换为 <code>true</code>。</p><h3 id="定义变量">定义变量</h3><p>简单来说<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，定义一个变量，需要包含类型说明符（指明变量的类型），以及要定义的变量名。</p><p>例如，下面这几条语句都是变量定义语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> hello;<br><span class="hljs-type">double</span> swufe;<br><span class="hljs-type">char</span> acm = <span class="hljs-string">&#x27;6&#x27;</span>;<br></code></pre></td></tr></table></figure><p>在目前我们所接触到的程序段中，定义在花括号内部的变量是局部变量，而定义在所有花括号外部的变量是全局变量。实际有例外，但是现在不必了解。</p><p>定义时没有初始化值的全局变量会被初始化为 <code>0</code>。而局部变量没有这种特性，需要手动赋初始值，否则可能引起难以发现的 bug。</p><h3 id="变量作用域">变量作用域</h3><p>变量的作用域是指变量在程序中有效的范围。</p><ul><li><strong>全局变量的作用域</strong>：自其定义之处开始，至文件结束位置为止。</li><li><strong>局部变量的作用域</strong>：自其定义之处开始，至代码块结束位置为止。</li></ul><p>由一对大括号括起来的若干语句构成一个代码块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">6</span>; <span class="hljs-comment">// 定义全局变量</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">555</span>;       <span class="hljs-comment">// 定义局部变量</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, x); <span class="hljs-comment">// 输出 x</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个代码块的内嵌块中定义了相同变量名的变量，则内层块中将无法访问外层块中相同变量名的变量。</p><p>例如上面的代码中，输出的 <code>x</code> 的值将是 <code>555</code>。因此为了防止出现意料之外的错误，请尽量避免局部变量与全局变量重名的情况。</p><h3 id="常量">常量</h3><p>常量，又称常变量，值为固定值，在程序执行期间不会改变。</p><p>常量的值在定义后不能被修改。定义时加一个 <code>const</code> 关键字即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi = <span class="hljs-number">3.1415926</span>;<br>Pi = <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>如果修改了常量的值，在编译环节就会报错：<code>error: assignment of read-only variable‘Pi’</code>。</p><hr><h2 id="运算">运算</h2><h3 id="算术运算符">算术运算符</h3><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code> (单目)</td><td style="text-align:left">取正</td></tr><tr><td style="text-align:left"><code>-</code> (单目)</td><td style="text-align:left">取负</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">乘法</td></tr><tr><td style="text-align:left"><code>/</code></td><td style="text-align:left">除法</td></tr><tr><td style="text-align:left"><code>%</code></td><td style="text-align:left">取模</td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">加法</td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">减法</td></tr></tbody></table><p>单目运算符（又称一元运算符）指被操作对象只有一个的运算符，而双目运算符（又称二元运算符）的被操作对象有两个。例如 <code>1 + 2</code> 中加号就是双目运算符，它有 <code>1</code> 和 <code>2</code> 两个被操作数。</p><p>算术运算符中有两个单目运算符（取正、取负）以及五个双目运算符（乘法、除法、取模、加法、减法），其中单目运算符的优先级最高。</p><p>其中取模运算符 <code>%</code> 意为计算两个整数相除得到的余数，即求余数。</p><p>C++ 中的算术运算遵循数学中加减乘除的优先规律，首先进行优先级高的运算，同优先级自左向右运算，括号提高优先级。</p><h4 id="算术运算中的类型转换">算术运算中的类型转换</h4><p>对于双目算术运算符，当参与运算的两个变量类型相同时，不发生类型转换，运算结果将会用参与运算的变量的类型容纳，否则会发生类型转换，以使两个变量的类型一致。</p><p>转换的规则如下：</p><ul><li>先将 <code>char</code>、<code>bool</code>、<code>short</code> 等类型提升至 <code>int</code>（或 <code>unsigned int</code>，取决于原类型的符号性）类型；</li><li>若存在一个变量类型为 <code>long double</code>，会将另一变量转换为 <code>long double</code> 类型；</li><li>否则，若存在一个变量类型为 <code>double</code>，会将另一变量转换为 <code>double</code> 类型；</li><li>否则，若存在一个变量类型为 <code>float</code>，会将另一变量转换为 <code>float</code> 类型；</li><li>否则（即参与运算的两个变量均为整数类型）：<ul><li>若两个变量符号性一致，则将位宽较小的类型转换为位宽较大的类型；</li><li>否则，若无符号变量的位宽不小于带符号变量的位宽，则将带符号数转换为无符号数对应的类型；</li><li>否则，若带符号操作数的类型能表示无符号操作数类型的所有值，则将无符号操作数转换为带符号操作数对应的类型；</li><li>否则，将带符号数转换为相对应的无符号类型。</li></ul></li></ul><p>例如，对于一个整型 <code>int</code> 变量 <code>x</code> 和另一个双精度浮点型 <code>double</code> 类型变量 <code>y</code>：</p><ul><li><code>x/5</code> 的结果将会是整型 <code>int</code>；</li><li><code>x/5.0</code> 的结果将会是双精度浮点型 <code>double</code>；</li><li><code>x/y</code> 的结果将会是双精度浮点型 <code>double</code>；</li><li><code>x*2/5</code> 的结果将会是整型 <code>int</code>；</li><li><code>x*2.0/5</code> 的结果将会是双精度浮点型 <code>double</code>；</li></ul><h3 id="位运算符">位运算符</h3><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>~</code> (单目)</td><td style="text-align:left">按位非</td></tr><tr><td style="text-align:left"><code>&amp;</code></td><td style="text-align:left">按位与</td></tr><tr><td style="text-align:left"><code>|</code></td><td style="text-align:left">按位或</td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">按位异或</td></tr><tr><td style="text-align:left"><code>&lt;&lt;</code></td><td style="text-align:left">按位左移</td></tr><tr><td style="text-align:left"><code>&gt;&gt;</code></td><td style="text-align:left">按位右移</td></tr></tbody></table><p>位运算就是基于整数的二进制表示进行的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。</p><p>需要注意的是，位运算符的优先级低于普通的算数运算符。</p><h3 id="自增-自减-运算符">自增/自减 运算符</h3><p>有时我们需要让变量进行增加 1（自增）或者减少 1（自减），这时自增运算符 <code>++</code> 和自减运算符 <code>--</code> 就派上用场了。</p><p>自增/自减运算符可放在变量前或变量后面，在变量前称为前缀，在变量后称为后缀，单独使用时前缀后缀无需特别区别，如果需要用到表达式的值则需注意，具体可看下面的例子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i = <span class="hljs-number">10</span>;<br>x1 = i++;  <span class="hljs-comment">// x1 = 10。先 x1 = i，然后 i = i + 1</span><br><br>i = <span class="hljs-number">10</span>;<br>x2 = ++i;  <span class="hljs-comment">// x2 = 11。先 i = i + 1，然后赋值 x2</span><br><br>i = <span class="hljs-number">10</span>;<br>x3 = i--;  <span class="hljs-comment">// x3 = 10。先赋值 x3，然后 i = i - 1</span><br><br>i = <span class="hljs-number">10</span>;<br>x4 = --i;  <span class="hljs-comment">// x4 = 9。先 i = i - 1，然后赋值 x4</span><br></code></pre></td></tr></table></figure><h3 id="复合赋值运算符">复合赋值运算符</h3><p>复合赋值运算符实际上是表达式的缩写形式。可分为复合算术运算符 <code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code> 和复合位运算符 <code>&amp;=</code>、<code>|=</code>、<code>^=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>。</p><p>例如，<code>x = x + 2</code> 可写为 <code>x += 2</code>，<code>x = x - 2</code> 可写为 <code>x -= 2</code>，<code>x = x * 2</code> 可写为 <code>x *= 2</code>。</p><h3 id="条件运算符">条件运算符</h3><p>条件运算符可以看作 <code>if</code> 语句的简写，<code>a ? b : c</code> 中如果表达式 <code>a</code> 成立，那么这个条件表达式的结果是 <code>b</code>，否则条件表达式的结果是 <code>c</code>。</p><p>条件运算符是 C++ 中唯一的三目运算符，所以平常说的三目运算符就是指条件运算符。</p><h3 id="比较运算符">比较运算符</h3><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>&gt;</code></td><td style="text-align:left">大于</td></tr><tr><td style="text-align:left"><code>&gt;=</code></td><td style="text-align:left">大于等于</td></tr><tr><td style="text-align:left"><code>&lt;</code></td><td style="text-align:left">小于</td></tr><tr><td style="text-align:left"><code>&lt;=</code></td><td style="text-align:left">小于等于</td></tr><tr><td style="text-align:left"><code>==</code></td><td style="text-align:left">等于</td></tr><tr><td style="text-align:left"><code>!=</code></td><td style="text-align:left">不等于</td></tr></tbody></table><p>其中特别需要注意的是要将等于运算符 <code>==</code> 和赋值运算符 <code>=</code> 区分开来，这在判断语句中尤为重要。</p><p><code>if (x=1)</code> 与 <code>if (x==1)</code> 看起来类似，但实际功能却相差甚远。第一条语句是在对 <code>x</code> 进行赋值，若赋值为非 <code>0</code> 时为真值，表达式的条件始终是满足的，无法达到判断的作用；而第二条语句才是对 <code>x</code> 的值进行判断。</p><h3 id="逻辑运算符">逻辑运算符</h3><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>&amp;&amp;</code></td><td style="text-align:left">逻辑与</td></tr><tr><td style="text-align:left"><code>||</code></td><td style="text-align:left">逻辑或</td></tr><tr><td style="text-align:left"><code>!</code></td><td style="text-align:left">逻辑非</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">c = a &amp;&amp; b;  <span class="hljs-comment">// 当 a 与 b 都为真时则 c 为真</span><br>c = a || b;  <span class="hljs-comment">// 当 a 或 b 其中一个为真时则 c 为真</span><br>c = !a;  <span class="hljs-comment">// 当 a 为假时则 c 为真</span><br></code></pre></td></tr></table></figure><h3 id="逗号运算符">逗号运算符</h3><p>逗号运算符可将多个表达式分隔开来，被分隔开的表达式按从左至右的顺序依次计算，整个表达式的值是最后的表达式的值。逗号表达式的优先级在所有运算符中的优先级是 <strong>最低</strong> 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x1, x2, x3;  <span class="hljs-comment">// 最后的值为 x3 的运算结果。</span><br><br>x = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>, <span class="hljs-number">3</span> + <span class="hljs-number">4</span>, <span class="hljs-number">5</span> + <span class="hljs-number">6</span>;  <span class="hljs-comment">//得到 x 的值为 3 而不是 11</span><br><span class="hljs-comment">// 因为赋值运算符 &quot;=&quot; 的优先级比逗号运算符高，先进行了赋值运算才进行逗号运算。</span><br><br>x = (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>, <span class="hljs-number">3</span> + <span class="hljs-number">4</span>, <span class="hljs-number">5</span> + <span class="hljs-number">6</span>);  <span class="hljs-comment">// 得到 x 的值为 11</span><br><span class="hljs-comment">// 若要让 x 的值得到逗号运算的结果，则应将整个表达式用括号提高优先级。</span><br></code></pre></td></tr></table></figure><h3 id="成员访问运算符">成员访问运算符</h3><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>[]</code></td><td style="text-align:left">数组下标</td></tr><tr><td style="text-align:left"><code>.</code></td><td style="text-align:left">对象成员</td></tr><tr><td style="text-align:left"><code>&amp;</code> (单目)</td><td style="text-align:left">取地址/获取引用</td></tr><tr><td style="text-align:left"><code>*</code> (单目)</td><td style="text-align:left">间接寻址/解引用</td></tr><tr><td style="text-align:left"><code>-&gt;</code></td><td style="text-align:left">指针成员</td></tr></tbody></table><p>这些运算符用来访问对象的成员或者内存。这里还省略了两个很少用到的运算符 <code>.*</code> 和 <code>-&gt;*</code> ，其具体用法可以参见 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/operator_member_access">C++ 语言手册</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> result1 = arr[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 获取 arr 中下标为 1 的对象</span><br><span class="hljs-keyword">auto</span> result2 = p.q;     <span class="hljs-comment">// 获取 p 对象的 q 成员</span><br><span class="hljs-keyword">auto</span> result3 = p -&gt; q;  <span class="hljs-comment">// 获取 p 指针指向的对象的 q 成员，等价于 (*p).q</span><br><span class="hljs-keyword">auto</span> result4 = &amp;v;      <span class="hljs-comment">// 获取指向 v 的指针</span><br><span class="hljs-keyword">auto</span> result5 = *v;      <span class="hljs-comment">// 获取 v 指针指向的对象</span><br></code></pre></td></tr></table></figure><h3 id="C-运算符优先级总表">C++ 运算符优先级总表</h3><p>来自 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/operator_precedence">C++ 运算符优先级 - cppreference</a>，有修改。</p><table><thead><tr><th style="text-align:center">优先级</th><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:center">结合性</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:left"><code>::</code></td><td style="text-align:left">作用域解析</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left"><code>++</code><br><code>--</code><br><code>type()</code>、<code>type&#123;&#125;</code><br><code>f()</code><br><code>a[]</code><br><code>.</code>、<code>-&gt;</code></td><td style="text-align:left">后缀自增<br>后缀自减<br>函数风格转型<br>函数调用<br>下标访问<br>成员访问</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left"><code>++a</code><br><code>--a</code><br><code>+a</code><br><code>-a</code><br><code>!</code><br><code>~</code><br><code>(type)</code><br><code>*a</code><br><code>&amp;a</code><br><code>sizeof</code><br><code>new</code><br><code>new[]</code><br><code>delete</code><br><code>delete[]</code></td><td style="text-align:left">前缀自增<br>前缀自减<br>取正<br>取负<br>逻辑非<br>按位非<br>C 风格转型<br>间接寻址/解引用<br>取地址/获取引用<br>返回类型大小<br>动态元素类型分配<br>动态数组类型分配<br>动态析构元素内存<br>动态析构数组内存</td><td style="text-align:center">从右到左</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left"><code>.*</code><br><code>-&gt;*</code></td><td style="text-align:left">类对象成员引用<br>类指针成员引用</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left"><code>*</code><br><code>/</code><br><code>%</code></td><td style="text-align:left">乘法<br>除法<br>取模</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left"><code>+</code><br><code>-</code></td><td style="text-align:left">加法<br>减法</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">7</td><td style="text-align:left"><code>&lt;&lt;</code><br><code>&gt;&gt;</code></td><td style="text-align:left">左移<br>右移</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">8</td><td style="text-align:left"><code>&lt;=&gt;</code></td><td style="text-align:left">三路比较</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">9</td><td style="text-align:left"><code>&lt;</code><br><code>&lt;=</code><br><code>&gt;</code><br><code>&gt;=</code></td><td style="text-align:left">小于<br>小于等于<br>大于<br>大于等于</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">10</td><td style="text-align:left"><code>==</code><br><code>!=</code></td><td style="text-align:left">等于<br>不等于</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">11</td><td style="text-align:left"><code>&amp;</code></td><td style="text-align:left">按位与</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">12</td><td style="text-align:left"><code>^</code></td><td style="text-align:left">按位异或</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">13</td><td style="text-align:left"><code>|</code></td><td style="text-align:left">按位或</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">14</td><td style="text-align:left"><code>&amp;&amp;</code></td><td style="text-align:left">逻辑与</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">15</td><td style="text-align:left"><code>||</code></td><td style="text-align:left">逻辑或</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">16</td><td style="text-align:left"><code>?:</code><br><code>throw</code><br><code>=</code><br><code>+=</code><br><code>-=</code><br><code>*=</code><br><code>/=</code><br><code>%=</code><br><code>&lt;&lt;=</code><br><code>&gt;&gt;=</code><br><code>&amp;=</code><br><code>^=</code><br><code>|=</code></td><td style="text-align:left">条件运算符<br>抛出异常<br>赋值<br>加赋值<br>减赋值<br>乘赋值<br>除赋值<br>取模赋值<br>左移赋值<br>右移赋值<br>按位与赋值<br>按位异或赋值<br>按位或赋值</td><td style="text-align:center">从右到左</td></tr><tr><td style="text-align:center">17</td><td style="text-align:left"><code>,</code></td><td style="text-align:left">逗号</td><td style="text-align:center">从左到右</td></tr></tbody></table><hr><h2 id="流程控制">流程控制</h2><h3 id="分支结构">分支结构</h3><p>一个程序默认是按照代码的顺序执行下来的，有时我们需要选择性的执行某些语句，这时候就需要分支的功能来实现。选择合适的分支语句可以提高程序的效率。</p><h4 id="if-语句">if 语句</h4><h5 id="基本-if-语句">基本 if 语句</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (条件)<br>&#123;<br>    主体;<br>&#125;<br></code></pre></td></tr></table></figure><p>if 语句通过对条件进行求值，若结果为真（非 0），执行语句，否则不执行。</p><p>如果主体中只有单个语句的话，花括号可以省略。</p><h5 id="if…else-语句">if…else 语句</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (条件)<br>&#123;<br>    主体<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    主体<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>if…else 语句和 if 语句类似，else 不需要再写条件。当 if 语句的条件满足时会执行 if 里的语句，if 语句的条件不满足时会执行 else 里的语句。同样，当主体只有一条语句时，可以省略花括号。</p><h5 id="else-if-语句">else if 语句</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (条件<span class="hljs-number">1</span>)<br>&#123;<br>    主体<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件<span class="hljs-number">2</span>)<br>&#123;<br>    主体<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件<span class="hljs-number">3</span>)<br>&#123;<br>    主体<span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    主体<span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>else if 语句是 if 和 else 的组合，对多个条件进行判断并选择不同的语句分支。在最后一条的 else 语句不需要再写条件。例如，若条件 1 为真，执行主体 1，条件 3 为真而条件 1 和条件 2 都为假，执行主体 3，所有的条件都为假才执行主体 4。</p><p>实际上，这一个语句相当于第一个 if 的 else 分句只有一个 if 语句，就将花括号省略之后放在一起了。如果条件相互之间是并列关系，这样写可以让代码的逻辑更清晰。</p><h4 id="switch-语句">switch 语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span> (选择句)<br>&#123;<br><span class="hljs-keyword">case</span> 标签<span class="hljs-number">1</span>:<br>    主体<span class="hljs-number">1</span>;<br><span class="hljs-keyword">case</span> 标签<span class="hljs-number">2</span>:<br>    主体<span class="hljs-number">2</span>;<br><span class="hljs-keyword">default</span>:<br>    主体<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>switch 语句执行时，先求出选择句的值，然后根据选择句的值选择相应的标签，从标签处开始执行。其中，选择句必须是一个整数类型表达式，而标签都必须是整数类型的常量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// 这里的 i 的数据类型是整型 ，满足整数类型的表达式的要求</span><br><br><span class="hljs-keyword">switch</span> (i)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;SWUFE&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> i = <span class="hljs-string">&#x27;A&#x27;</span>;<br><br><span class="hljs-comment">// 这里的 i 的数据类型是字符型 ，但 char</span><br><span class="hljs-comment">// 也是属于整数的类型，满足整数类型的表达式的要求</span><br><span class="hljs-keyword">switch</span> (i)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;SWUFE&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>switch 语句中还要根据需求加入 break 语句进行中断，否则在对应的 case 被选择之后接下来的所有 case 里的语句和 default 里的语句都会被运行。具体例子可看下面的示例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> i = <span class="hljs-string">&#x27;B&#x27;</span>;<br><br><span class="hljs-keyword">switch</span> (i)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;SWUFE&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;ACM&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-keyword">default</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码运行后输出的结果为 <code>ACM</code> 和 <code>Hello World</code>，如果不想让下面分支的语句被运行就需要 break 了，具体例子可看下面的示例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> i = <span class="hljs-string">&#x27;B&#x27;</span>;<br><br><span class="hljs-keyword">switch</span> (i)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;SWUFE&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;ACM&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码运行后输出的结果为 <code>ACM</code>，因为 break 的存在，接下来的语句就不会继续被执行了。最后一个语句不需要 break，因为下面没有语句了。</p><p>处理入口编号不能重复，但可以颠倒。也就是说，入口编号的顺序不重要。各个 case（包括 default）的出现次序可任意。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> i = <span class="hljs-string">&#x27;B&#x27;</span>;<br><br><span class="hljs-keyword">switch</span> (i)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;ACM&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">default</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>    cout &lt;&lt; <span class="hljs-string">&quot;SWUFE&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>switch 的 case 分句中也可以选择性的加花括号。不过要注意的是，如果需要在 switch 语句中定义变量，花括号是必须要加的。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> i = <span class="hljs-string">&#x27;B&#x27;</span>;<br><br><span class="hljs-keyword">switch</span> (i)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">2</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;SWUFE&quot;</span> &lt;&lt; endl;<br>    ans = i + j;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">3</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;ACM&quot;</span> &lt;&lt; endl;<br>    ans = x * x;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">default</span>:<br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环结构">循环结构</h3><p>有时，我们需要做一件事很多遍，为了不写过多重复的代码，我们需要循环。</p><p>有时，循环的次数不是一个常量，那么我们无法将代码重复多遍，必须使用循环。</p><h4 id="for-循环">for 循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (初始化; 判断条件; 更新)<br>&#123;<br>    循环体;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程图：</p><p><img src="/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" data-lazy-src="https://img-blog.csdnimg.cn/f64f13cb78ee44eaa167d36f4de14226.png" alt="for 循环"></p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 读入 n 个数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br>    cin &gt;&gt; a[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>for 循环的三个部分中，任何一个部分都可以省略。其中，若省略了判断条件，相当于判断条件永远为真。</p><h4 id="while-循环">while 循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (判断条件)<br>&#123;<br>    循环体;<br>&#125;<br></code></pre></td></tr></table></figure><p>流程图：</p><p><img src="/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" data-lazy-src="https://img-blog.csdnimg.cn/79f3e4ce493b49bcbb160ea4ca61f8a5.png" alt="while 循环"></p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 验证科拉茨猜想</span><br><span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>    &#123;<br>        x = <span class="hljs-number">3</span> * x + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        x = x / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="do…while-循环">do…while 循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">do</span><br>&#123;<br>    循环体;<br>&#125; <span class="hljs-keyword">while</span> (判断条件);<br></code></pre></td></tr></table></figure><p>流程图：</p><p><img src="/img/loading.gif" onerror="this.onerror=null,this.src=&quot;/img/friend_404.gif&quot;" data-lazy-src="https://img-blog.csdnimg.cn/fe74b54a4fc748518fe2d3f1dd64d27d.png" alt="do...while 循环"></p><p>与 while 语句的区别在于，do…while 语句是先执行循环体再进行判断的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 枚举排列</span><br><span class="hljs-keyword">do</span><br>&#123;<br>    <span class="hljs-comment">// do someting...</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><h4 id="三种循环的联系">三种循环的联系</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// for 循环</span><br><span class="hljs-keyword">for</span> (statement1; statement2; statement3)<br>&#123;<br>    statement4;<br>&#125;<br><br><span class="hljs-comment">// while 循环</span><br>statement1;<br><span class="hljs-keyword">while</span> (statement2)<br>&#123;<br>    statement4;<br>    statement3;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 statement4 中没有 <code>continue</code> 语句（见下文）的时候是等价的，但是下面一种方法很少用到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// while 循环</span><br>statement1;<br><span class="hljs-keyword">while</span> (statement2)<br>&#123;<br>    statement1;<br>&#125;<br><br><span class="hljs-comment">// do...while 循环</span><br><span class="hljs-keyword">do</span><br>&#123;<br>    statement1;<br>&#125; <span class="hljs-keyword">while</span> (statement2);<br></code></pre></td></tr></table></figure><p>在 statement1 中没有 <code>continue</code> 语句的时候这两种方式也也是等价的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-comment">// do something...</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (;;)<br>&#123;<br>    <span class="hljs-comment">// do something...</span><br>&#125;<br><br><span class="hljs-keyword">do</span><br>&#123;<br>    <span class="hljs-comment">// do something...</span><br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>这三种方式都是永远循环下去，可以使用 <code>break</code>（见下文）退出。</p><p>可以看出，三种循环可以彼此代替，但一般来说，循环的选用遵守以下原则：</p><ol><li>循环过程中有个固定的增加步骤（最常见的是枚举）时，使用 for 循环；</li><li>只确定循环的终止条件时，使用 while 循环；</li><li>使用 while 循环时，若要先执行循环体再进行判断，使用 do…while 循环。一般很少用到，常用场景是用户输入。</li></ol><h4 id="break-与-continue-语句">break 与 continue 语句</h4><p><code>break</code> 语句的作用是退出循环。</p><p><code>continue</code> 语句的作用是跳过循环体的余下部分。下面以 <code>continue</code> 语句在 do…while 语句中的使用为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">do</span><br>&#123;<br>    <span class="hljs-comment">// do something...</span><br>    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 等价于 goto END;</span><br><span class="hljs-comment">// do something...</span><br>END:;<br>&#125; <span class="hljs-keyword">while</span> (statement);<br></code></pre></td></tr></table></figure><p><code>break</code> 与 <code>continue</code> 语句均可在三种循环语句的循环体中使用。</p><p>一般来说，<code>break</code> 与 <code>continue</code> 语句用于让代码的逻辑更加清晰，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 逻辑较为不清晰，大括号层次复杂</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&#123;<br>    <span class="hljs-keyword">if</span> (i != x)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (j != x)<br>            &#123;<br>                <span class="hljs-comment">// do something...</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 逻辑更加清晰，大括号层次简单明了</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&#123;<br>    <span class="hljs-keyword">if</span> (i == x)<br>        <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (j == x)<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// do something...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// for 语句判断条件复杂，没有体现「枚举」的本质</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r &amp;&amp; i % <span class="hljs-number">10</span> != <span class="hljs-number">0</span>; ++i)<br>&#123;<br>    <span class="hljs-comment">// do something...</span><br>&#125;<br><br><span class="hljs-comment">// for 语句用于枚举，break 用于「到何时为止」</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; ++i)<br>&#123;<br>    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// do something...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 语句重复，顺序不自然</span><br>statement1;<br><span class="hljs-keyword">while</span> (statement3)<br>&#123;<br>    statement2;<br>    statement1;<br>&#125;<br><br><span class="hljs-comment">// 没有重复语句，顺序自然</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>    statement1;<br>    <span class="hljs-keyword">if</span> (!statement3)<br>        <span class="hljs-keyword">break</span>;<br>    statement2;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="高级数据类型">高级数据类型</h2><h3 id="数组">数组</h3><p>数组是存放相同类型对象的容器，数组中存放的对象没有名字，而是要通过其所在的位置访问。数组的大小是固定的，不能随意改变数组的长度。</p><h4 id="定义数组">定义数组</h4><p>数组的声明形如 <code>a[n]</code>，其中，<code>a</code> 是数组的名字，<code>n</code> 是数组中元素的个数。在编译时，<code>n</code> 应该是已知的，也就是说，<code>n</code> 应该是一个整型的常量表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n1 = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n2 = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> arr1[n1];  <span class="hljs-comment">// 错误：n1 不是常量表达式</span><br><span class="hljs-type">int</span> arr2[n2];  <span class="hljs-comment">// 正确：arr2 是一个长度为 42 的数组</span><br></code></pre></td></tr></table></figure><p>不能将一个数组直接赋值给另一个数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr1[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> arr2 = arr1;  <span class="hljs-comment">// 错误</span><br>arr2 = arr1;      <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>应该尽量将较大的数组定义为全局变量。因为局部变量会被创建在栈区中，过大（大于栈的大小）的数组会爆栈，进而导致 RE。如果将数组声明在全局作用域中，就会在静态区中创建数组。</p><h4 id="访问数组元素">访问数组元素</h4><p>可以通过下标运算符 <code>[]</code> 来访问数组内元素，数组的索引（即方括号中的值）从 0 开始。以一个包含 10 个元素的数组为例，它的索引为 0 到 9，而非 1 到 10。但在程序设计中，为了使用方便，我们通常会将数组开大一点，不使用数组的第一个元素，从下标 1 开始访问数组元素。</p><p><strong>例1</strong></p><p>从标准输入中读取一个整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span>，再读取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 个数，存入数组中。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">n\leq 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719em;vertical-align:-.136em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1000</span></span></span></span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">1001</span>]; <span class="hljs-comment">// 数组 arr 的下标范围是 [0, 1001)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        cin &gt;&gt; arr[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>例2</strong></p><p>（接例 1）求和数组 <code>arr</code> 中的元素，并输出和。满足数组中所有元素的和小于等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8974em;vertical-align:-.0833em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1</span></span></span></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">1001</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        cin &gt;&gt; arr[i];<br>    &#125;<br><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    &#123;<br>        sum += arr[i];<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="越界访问下标">越界访问下标</h5><p>数组的下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\mathit{idx}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord"><span class="mord mathit">idx</span></span></span></span></span> 应当满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mrow><mi>i</mi><mi>d</mi><mi>x</mi></mrow><mo>&lt;</mo><mrow><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow></mrow><annotation encoding="application/x-tex">0\leq \mathit{idx}&lt; \mathit{size}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7804em;vertical-align:-.136em"></span><span class="mord">0</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.7335em;vertical-align:-.0391em"></span><span class="mord"><span class="mord mathit">idx</span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6554em"></span><span class="mord"><span class="mord mathit">size</span></span></span></span></span>，如果下标越界，则会产生不可预料的后果，如段错误（Segmentation Fault），或者修改预期以外的变量。</p><h4 id="多维数组">多维数组</h4><p>多维数组的实质是「数组的数组」，即外层数组的元素是数组。一个二维数组需要两个维度来定义：数组的长度和数组内元素的长度。访问二维数组时需要写出两个索引：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>][<span class="hljs-number">4</span>];  <span class="hljs-comment">// 一个长度为 5 的数组，它的元素是「元素为 int 的长度为的 4 的数组」</span><br>arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 访问二维数组</span><br></code></pre></td></tr></table></figure><p>我们经常使用嵌套的 for 循环来处理二维数组。</p><p><strong>例</strong></p><p>从标准输入中读取两个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">m</span></span></span></span>，分别表示黑白图片的高与宽，满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">n,m\leq 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8304em;vertical-align:-.1944em"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">1000</span></span></span></span>。对于接下来的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">n</span></span></span></span> 行数据，每行有用空格分隔开的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">m</span></span></span></span> 个数，代表这一位置的亮度值。现在我们读取这张图片，并将其存入二维数组中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1001</span>;<br><span class="hljs-type">int</span> pic[maxn][maxn];<br><span class="hljs-type">int</span> n, m;<br><br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)<br>        cin &gt;&gt; pic[i][j];<br></code></pre></td></tr></table></figure><p>类似地，你可以定义三维、四维，以及更高维的数组。</p><h3 id="结构体">结构体</h3><p>结构体（struct），可以看做是一系列称为成员元素的组合体。</p><p>可以看做是自定义的数据类型。</p><p><em>本节描述的 <code>struct</code> 不同于 C 中 <code>struct</code>，在 C++ 中 <code>struct</code> 被扩展为类似 <code>class</code> 的类说明符。</em></p><h4 id="定义结构体">定义结构体</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Object</span><br>&#123;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> value;<br>&#125; e[array_length];<br><br><span class="hljs-type">const</span> Object a;<br>Object b, B[array_length], tmp;<br>Object *c;<br></code></pre></td></tr></table></figure><p>上例中定义了一个名为 <code>Object</code> 的结构体，两个成员元素 <code>value</code>、<code>weight</code>，类型都为 <code>int</code>。</p><p>在 <code>&#125;</code> 后，定义了数据类型为 <code>Object</code> 的常量 <code>a</code>，变量 <code>b</code>，变量 <code>tmp</code>，数组 <code>B</code>，指针 <code>c</code>。对于某种已经存在的类型，都可以使用这里的方法进行定义常量、变量、指针、数组等。</p><h4 id="访问-修改成员元素">访问/修改成员元素</h4><p>可以使用 <code>变量名.成员元素名</code> 进行访问。</p><p>如：输出 <code>var</code> 的 <code>v</code> 成员：<code>cout &lt;&lt; var.v</code>。</p><p>也可以使用 <code>指针名-&gt;成员元素名</code> 或者 使用 <code>(*指针名).成员元素名</code> 进行访问。</p><p>如：将结构体指针 <code>ptr</code> 指向的结构体的成员元素 <code>v</code> 赋值为 <code>tmp</code>：<code>(*ptr).v = tmp</code> 或者 <code>ptr-&gt;v = tmp</code>。</p><h4 id="结构体的意义">结构体的意义</h4><p>首先，条条大路通罗马，可以不使用结构体达到相同的效果。结构体的意义在于，它能够显式地将成员元素（在程序设计比赛中通常是变量）捆绑在一起，如本例中的 <code>Object</code> 结构体，便将 <code>value</code>、<code>weight</code> 放在了一起（定义这个结构体的实际意义是表示一件物品的重量与价值）。这样的好处边是限制了成员元素的使用。</p><p>想象一下，如果不使用结构体而使用两个数组 <code>value[]</code>、<code>weight[]</code>，很容易写混淆。但如果使用结构体，能够减轻出现使用变量错误的几率。</p><p>并且不同的结构体（结构体类型，如 <code>Object</code> 这个结构体）或者不同的结构体变量（结构体的实例，如上方的 <code>e</code> 数组）可以拥有相同名字的成员元素（如 <code>tmp.value</code>、<code>b.value</code>），同名的成员元素相互独立（拥有独自的内存，比如说修改 <code>tmp.value</code> 不会影响 <code>b.value</code> 的值）。</p><p>这样的好处是可以使用尽可能相同或者相近的变量去描述一个物品。比如说 <code>Object</code> 里有 <code>value</code> 这个成员变量；我们还可以定义一个 <code>Car</code> 结构体，同时也拥有 <code>value</code> 这个成员；如果不使用结构体，或许我们就需要定义 <code>valueOfObject[]</code>,<code>valueOfCar[]</code> 等不同名称的数组来区分。</p><p><em>如果想要更详细的描述一种事物，还可以定义成员函数。C++ 中的类就是为此而生的。</em></p><h4 id="结构体的弊端">结构体的弊端</h4><p>为了访问内存的效率更高，编译器在处理结构体中成员的实际存储情况时，可能会将成员对齐在一定的字节位置，也就意味着结构体中有空余的地方。因此，该结构体所占用的空间可能大于其中所有成员所占空间的总和。</p><h3 id="指针">指针</h3><h4 id="变量的地址、指针">变量的地址、指针</h4><p>在程序中，我们的数据都有其存储的地址。在程序每次的实际运行过程中，变量在物理内存中的存储位置不尽相同。不过，我们仍能够在编程时，通过一定的语句，来取得数据在内存中的地址。</p><p>地址也是数据。存放地址所用的变量类型有一个特殊的名字，叫做「指针变量」，有时也简称做「指针」。</p><p>指针变量的大小与机器的位数有关，32 位机器上的指针变量通常是 4 字节，64 位机器上的指针变量通常是 8 字节。</p><p>地址只是一个刻度一般的数据，为了针对不同类型的数据，「指针变量」也有不同的类型，比如，可以有 <code>int</code> 类型的指针变量，其中存储的地址（即指针变量存储的数值）对应一块大小为 32 位的空间的起始地址；有 <code>char</code> 类型的指针变量，其中存储的地址对应一块 8 位的空间的起始地址。</p><p>事实上，用户也可以声明指向指针变量的指针变量。</p><p>假如用户自定义了一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoInt</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><p>则 <code>TwoInt</code> 类型的指针变量，对应着一块 2 × 32 = 64 bit 的空间。</p><h4 id="指针的声明与使用">指针的声明与使用</h4><p>C/C++ 中，指针变量的类型为类型名后加上一个星号 <code>*</code>。比如，<code>int</code> 类型的指针变量的类型名即为 <code>int*</code>。</p><p>我们可以使用 <code>&amp;</code> 符号取得一个变量的地址。</p><p>要想访问指针变量地址所对应的空间（又称指针所 <strong>指向</strong> 的空间），需要对指针变量进行 <strong>解引用</strong>（dereference），使用 <code>*</code> 符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">123</span>; <span class="hljs-comment">// a: 123</span><br>    <span class="hljs-type">int</span> *pa = &amp;a;<br>    *pa = <span class="hljs-number">321</span>; <span class="hljs-comment">// a: 321</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对结构体变量也是类似。如果要访问指针指向的结构中的成员，需要先对指针进行解引用，再使用 <code>.</code> 成员关系运算符。不过，更推荐使用「箭头」运算符 <code>-&gt;</code> 这一更简便的写法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoInt</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TwoInt x&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, y&#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br>    TwoInt *px = &amp;x;<br>    (*px) = y;   <span class="hljs-comment">// x: &#123;6,7&#125;</span><br>    (*px).a = <span class="hljs-number">4</span>; <span class="hljs-comment">// x: &#123;4,7&#125;</span><br>    px-&gt;b = <span class="hljs-number">5</span>;   <span class="hljs-comment">// x: &#123;4,5&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="指针的偏移">指针的偏移</h4><p>指针变量也可以和整数进行加减操作。对于 <code>int</code> 型指针，每加 1（递增 1），其指向的地址偏移 32 位（即 4 个字节）；若加 2，则指向的地址偏移 2 × 32 = 64 位。同理，对于 <code>char</code> 型指针，每次递增，其指向的地址偏移 8 位（即 1 个字节）。</p><h5 id="使用指针偏移访问数组">使用指针偏移访问数组</h5><p>我们前面说过，数组是一块连续的存储空间。而在 C/C++ 中，直接使用数组名，得到的是数组的起始地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-type">int</span> *p = a; <span class="hljs-comment">// p 指向 a[0]</span><br>    *p = <span class="hljs-number">4</span>;     <span class="hljs-comment">// a: [4, 1, 2]</span><br>    p = p + <span class="hljs-number">1</span>;  <span class="hljs-comment">// p 指向 a[1]</span><br>    *p = <span class="hljs-number">5</span>;     <span class="hljs-comment">// a: [4, 5, 2]</span><br>    p++;        <span class="hljs-comment">// p 指向 a[2]</span><br>    *p = <span class="hljs-number">6</span>;     <span class="hljs-comment">// a: [4, 5, 6]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当通过指针访问数组中的元素时，往往需要用到「指针的偏移」，换句话说，即通过一个基地址（数组起始的地址）加上偏移量来访问。</p><p>我们常用 <code>[]</code> 运算符来访问数组中某一指定偏移量处的元素。比如 <code>a[1]</code> 或者 <code>p[3]</code>。这种写法和对指针进行运算后再引用是等价的，即 <code>p[5]</code> 和 <code>*(p + 5)</code> 是等价的两种写法。</p><h4 id="空指针">空指针</h4><p>在 C<ins>11 之前，C</ins> 和 C 一样使用 NULL 宏表示空指针常量，C++ 中 <code>NULL</code> 的实现一般如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++11 前</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><br></code></pre></td></tr></table></figure><p>空指针和整数 0 的混用在 C++ 中会导致许多问题，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 函数重载</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span></span>;<br></code></pre></td></tr></table></figure><p>在调用 <code>f(NULL)</code> 时，实际调用的函数的类型是 <code>int(int)</code> 而不是 <code>int(int *)</code>。</p><p>为了解决这些问题，C++11 引入了 <code>nullptr</code> 关键字作为空指针常量。</p><p>C++ 规定 <code>nullptr</code> 可以隐式转换为任何指针类型，这种转换结果是该类型的空指针值。</p><p><code>nullptr</code> 的类型为 <code>std::nullptr_t</code>，称作空指针类型，可能的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span> <span class="hljs-type">nullptr_t</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，C++11 起 <code>NULL</code> 宏的实现也被修改为了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++11 起</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL nullptr</span><br></code></pre></td></tr></table></figure><h4 id="指针的进阶使用">指针的进阶使用</h4><p>使用指针，使得程序编写者可以操作程序运行时中各处的数据，而不必局限于作用域。</p><h5 id="指针类型参数的使用">指针类型参数的使用</h5><p>在 C/C++ 中，调用函数（过程）时使用的参数，均以拷贝的形式传入子过程中（引用除外，会在后续介绍）。默认情况下，函数仅能通过返回值，将结果返回到调用处。但是，如果某个函数希望修改其外部的数据，或者某个结构体/类的数据量较为庞大、不宜进行拷贝，这时，则可以通过向其传入外部数据的地址，便得以在其中访问甚至修改外部数据。</p><p>下面的 <code>swap</code> 方法，通过接收两个 <code>int</code> 型的指针，在函数中使用中间变量，完成对两个 <code>int</code> 型变量值的交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    t = *x;<br>    *x = *y;<br>    *y = t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">4</span>;<br>    <span class="hljs-built_in">swap</span>(&amp;x, &amp;y);<br>    <span class="hljs-comment">// 调用后，main 函数中 x 变量的值变为 4，y 变量的值变为 5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 中引入了引用的概念，相对于指针来说，更易用，也更安全。</p><h5 id="动态实例化">动态实例化</h5><p>除此之外，程序编写时往往会涉及到动态内存分配，即，程序会在运行时，向操作系统动态地申请或归还存放数据所需的内存。当程序通过调用操作系统接口申请内存时，操作系统将返回程序所申请空间的地址。要使用这块空间，我们需要将这块空间的地址存储在指针变量中。</p><p>在 C++ 中，我们使用 <code>new</code> 运算符来获取一块内存，使用 <code>delete</code> 运算符释放某指针所指向的空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">100</span>);<br><span class="hljs-comment">/* ... */</span><br><span class="hljs-keyword">delete</span> p;<br></code></pre></td></tr></table></figure><p>上面的语句使用 <code>new</code> 运算符向操作系统申请了一块 <code>int</code> 大小的空间，将其中的值初始化为 100，并声明了一个 <code>int</code> 型的指针 <code>p</code> 指向这块空间。</p><p>同理，也可以使用 <code>new</code> 开辟新的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a_) : <span class="hljs-built_in">a</span>(a_) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    A *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，「<code>new</code> 表达式」将尝试开辟一块对应大小的空间，并尝试在这块空间上构造这一对象，并返回这一空间的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TwoInt</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    TwoInt *p = <span class="hljs-keyword">new</span> TwoInt&#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&#123;&#125;</code> 运算符可以用来初始化没有构造函数的结构。除此之外，使用 <code>&#123;&#125;</code> 运算符可以使得变量的初始化形式变得统一，详见 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/list_initialization">列表初始化 (C++11 起) - cppreference</a>。</p><p>需要注意，当使用 <code>new</code> 申请的内存不再使用时，需要使用 <code>delete</code> 释放这块空间。不能对一块内存释放两次或以上。而对空指针 <code>nullptr</code> 使用 <code>delete</code> 操作是合法的。</p><h5 id="动态创建数组">动态创建数组</h5><p>也可以使用 <code>new[]</code> 运算符创建数组，这时 <code>new[]</code> 运算符会返回数组的首地址，也就是数组第一个元素的地址，我们可以用对应类型的指针存储这个地址。释放时，则需要使用 <code>delete[]</code> 运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">50</span>];<br><span class="hljs-keyword">delete</span>[] p;<br></code></pre></td></tr></table></figure><p>数组中元素的存储是连续的，即 <code>p + 1</code> 指向的是 <code>p</code> 的后继元素。</p><h5 id="二维数组">二维数组</h5><p>在存放矩阵形式的数据时，可能会用到「二维数组」这样的数据类型。从语义上来讲，二维数组是一个数组的数组。而计算机内存可以视作一个很长的一维数组。要在计算机内存中存放一个二维数组，便有「连续」与否的说法。</p><p>所谓「连续」，即二维数组的任意一行（row）的末尾与下一行的起始，在物理地址上是毗邻的，换言之，整个二维数组可以视作一个一维数组；反之，则二者在物理上不一定相邻。</p><p>对于「连续」的二维数组，可以仅使用一个循环，借由一个不断递增的指针即可遍历数组中的所有数据。而对于非连续的二维数组，由于每一行不连续，则需要先取得某一行首的地址，再访问这一行中的元素。</p><p>这种按照「行（row）」存储数据的方式，称为行优先存储；相对的，也可以按照列（column）存储数据。由于计算机内存访问的特性，一般来说，访问连续的数据会得到更高的效率。因此，需要按照数据可能的使用方式，选择「行优先」或「列优先」的存储方式。</p><h5 id="动态创建二维数组">动态创建二维数组</h5><p>在 C/C++ 中，我们可以使用类似下面这样的语句声明一个 N 行（row）M 列（column）<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>的二维数组，其空间在物理上是连续的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[N][M];<br></code></pre></td></tr></table></figure><p>这种声明方式要求 N 和 M 为在编译期即可确定的常量表达式。</p><p>在 C/C++ 中，数组的第一个元素下标为 0，因此 <code>a[r][c]</code> 这样的式子代表二维数组 a 中第 r + 1 行的第 c + 1 个元素，我们也称这个元素的下标为 <code>(r,c)</code>。</p><p>不过，实际使用中，（二维）数组的大小可能不是固定的，需要动态内存分配。</p><p>常见的方式是声明一个长度为 N × M 的 <strong>一维数组</strong><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>，并通过下标 <code>r * M + c</code> 访问二维数组中下标为 <code>(r, c)</code> 的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[N * M];<br></code></pre></td></tr></table></figure><p>这种方法可以保证二维数组是 <strong>连续的</strong>。</p><p>此外，亦可以根据「数组的数组」这一概念来进行内存的获取与使用。对于一个存放的若干数组的数组，实际上为一个存放的若干数组的首地址的数组，也就是一个存放若干指针变量的数组。</p><p>我们需要一个变量来存放这个「数组的数组」的首地址——也就是一个指针的地址。这个变量便是一个「指向指针的指针」，有时也称作「二重指针」，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>** a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>接着，我们需要为每一个数组申请空间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    a[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们便完成了内存的获取。而对于这样获得的内存的释放，则需要进行一个逆向的操作：即先释放每一个数组，再释放存储这些数组首地址的数组，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>&#123;<br>    <span class="hljs-keyword">delete</span>[] a[i];<br>&#125;<br><span class="hljs-keyword">delete</span>[] a;<br></code></pre></td></tr></table></figure><p>需要注意，这样获得的二维数组，不能保证其空间是连续的。</p><p>还有一种方式，需要使用到「指向数组的指针」。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">int</span>(*a)[<span class="hljs-number">5</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> *p = a[<span class="hljs-number">2</span>];<br>    a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">delete</span>[] a;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式获得到的也是连续的内存，但是可以直接使用 <code>a[n]</code> 的形式获得到数组的第 n + 1 行（row）的首地址，因此，使用 <code>a[r][c]</code> 的形式即可访问到下标为 <code>(r, c)</code> 的元素。</p><p>由于指向数组的指针也是一种确定的数据类型，因此除数组的第一维外，其他维度的长度均须为一个能在编译器确定的常量。不然，编译器将无法翻译如 <code>a[n]</code> 这样的表达式（<code>a</code> 为指向数组的指针）。</p><h4 id="指向函数的指针">指向函数的指针</h4><p>关于函数的介绍请参见本文 <strong>函数</strong> 章节。</p><p>简单地说，要调用一个函数，需要知晓该函数的参数类型、个数以及返回值类型，这些也统一称作接口类型。</p><p>可以通过函数指针调用函数。有时候，若干个函数的接口类型是相同的，使用函数指针可以根据程序的运行 <strong>动态地</strong> 选择需要调用的函数。换句话说，可以在不修改一个函数的情况下，仅通过修改向其传入的参数（函数指针），使得该函数的行为发生变化。</p><p>假设我们有若干针对 <code>int</code> 类型的二元运算函数，则函数的参数为 2 个 <code>int</code>，返回值亦为 <code>int</code>。下边是一个使用了函数指针的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-built_in">int</span> (*binary_int_op)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a * b + b; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> (a + b) * b; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> choice;<br>    std::cin &gt;&gt; choice;<br>    <span class="hljs-keyword">if</span> (choice == <span class="hljs-number">1</span>)<br>    &#123;<br>        binary_int_op = foo1;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        binary_int_op = foo2;<br>    &#125;<br><br>    <span class="hljs-type">int</span> m, n;<br>    std::cin &gt;&gt; m &gt;&gt; n;<br>    std::cout &lt;&lt; <span class="hljs-built_in">binary_int_op</span>(m, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用 <code>typdef</code> 关键字声明函数指针的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*p_bi_int_op)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>这样我们就可以在之后使用 <code>p_bi_int_op</code> 这种类型，即指向「参数为 2 个 <code>int</code>，返回值亦为 <code>int</code>」的函数的指针。</p><hr><h2 id="函数">函数</h2><h3 id="函数的声明">函数的声明</h3><p>编程中的函数（function）一般是若干语句的集合。我们也可以将其称作「<strong>子过程</strong>（subroutine）」。在编程中，如果有一些重复的过程，我们可以将其提取出来，形成一个函数。函数可以接收若干值，这叫做函数的参数。函数也可以返回某个值，这叫做函数的返回值。</p><p>声明一个函数，我们需要返回值类型、函数的名称，以及参数列表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回值类型 int</span><br><span class="hljs-comment">// 函数的名称 function</span><br><span class="hljs-comment">// 参数列表 int, int</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>如上图，我们声明了一个名为 <code>function</code> 的函数，它需要接收两个 <code>int</code> 类型的参数，返回值类型也为 <code>int</code>。可以认为，这个函数将会对传入的两个整数进行一些操作，并且返回一个同样类型的结果。</p><h3 id="实现函数：编写函数的定义">实现函数：编写函数的定义</h3><p>只有函数的声明（declaration）还不够，他只能让我们在调用时能够得知函数的 <strong>接口</strong> 类型（即接收什么数据、返回什么数据），但其缺乏具体的内部实现，也就是函数的 <strong>定义</strong>（definition）。我们可以在 <strong>声明之后的其他地方</strong> 编写代码 <strong>实现</strong>（implement）这个函数（也可以在另外的文件中实现，但是需要将分别编译后的文件在链接时一并给出）。</p><p>如果函数有返回值，则需要通过 <code>return</code> 语句，将值返回给调用方。函数一旦执行到 <code>return</code> 语句，则直接结束当前函数，不再执行后续的语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 声明</span><br><br><span class="hljs-comment">/* some other code here... */</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 定义</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">5</span> * x + y;<br>    <span class="hljs-keyword">return</span> result;<br>    result = <span class="hljs-number">4</span>; <span class="hljs-comment">// 这条语句不会被执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在定义时，我们给函数的参数列表的变量起了名字。这样，我们便可以在函数定义中使用这些变量了。</p><p>如果是同一个文件中，我们也可以直接将 <strong>声明和定义合并在一起</strong>，换句话说，也就是在声明时就完成定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span> * x + y; &#125;<br></code></pre></td></tr></table></figure><p>如果函数不需要有返回值，则将函数的返回值类型标为 <code>void</code>；如果函数不需要参数，则可以将参数列表置空。同样，无返回值的函数执行到 <code>return;</code> 语句也会结束执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_happy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;happy!\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;happy!\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;happy!\n&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;happy!\n&quot;</span>; <span class="hljs-comment">// 这条语句不会被执行</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数的调用">函数的调用</h3><p>和变量一样，函数需要先被声明，才能使用。使用函数的行为，叫做「调用（call）」。我们可以在任何函数内部调用其他函数，包括这个函数自身。函数调用自身的行为，称为 <strong>递归</strong>（recursion）。</p><p>在大多数语言中，调用函数的写法，是 <strong>函数名称加上一对括号</strong> <code>()</code>，如 <code>f()</code>。如果函数需要参数，则我们将其需要的参数按顺序填写在括号中，以逗号间隔，如 <code>f(1, 2)</code>。函数的调用也是一个表达式，<strong>函数的返回值</strong> 就是 <strong>表达式的值</strong>。</p><p>函数声明时候写出的参数，可以理解为在函数 <strong>当前次调用的内部</strong> 可以使用的变量，这些变量的值由调用处传入的值初始化。看下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-comment">/* ... */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    x = x * <span class="hljs-number">2</span>;<br>    y = y + <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-comment">/* ... */</span><br><br>a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 调用前：a = 1, b = 1</span><br><span class="hljs-built_in">f</span>(a, b); <span class="hljs-comment">// 调用 f</span><br>         <span class="hljs-comment">// 调用后：a = 1, b = 1</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>f(a, b)</code> 是一次对 <code>f</code> 的调用。调用时，<code>f</code> 中的 <code>x</code> 和 <code>y</code> 变量，分别由调用处 <code>a</code> 和 <code>b</code> 的值初始化。因此，在 <code>f</code> 中对变量 <code>x</code> 和 <code>y</code> 的修改，<strong>并不会影响到调用处的变量的值</strong>。</p><p>如果我们需要在函数（子过程）中修改变量的值，则需要采用「传引用」的方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    x = x * <span class="hljs-number">2</span>;<br>    y = y + <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-comment">/* ... */</span><br><br>a = <span class="hljs-number">2</span>;<br>b = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 调用前：a = 2, b = 2</span><br><span class="hljs-built_in">f</span>(a, b); <span class="hljs-comment">// 调用 f</span><br>         <span class="hljs-comment">// 调用后：a = 4, b = 5</span><br></code></pre></td></tr></table></figure><p>上述代码中，我们看到函数参数列表中的「<code>int</code>」后面添加了一个「<code>&amp;</code>（and 符号）」，这表示对于 <code>int</code> 类型的 <strong>引用</strong>（reference）。在调用 <code>f</code> 时，调用处 <code>a</code> 和 <code>b</code> 变量分别初始化了 <code>f</code> 中两个对 <code>int</code> 类型的引用 <code>x</code> 和 <code>y</code>。在 <code>f</code> 中的 <code>x</code> 和 <code>y</code>，可以理解为调用处 <code>a</code> 和 <code>b</code> 变量的「别名」，即 <code>f</code> 中对 <code>x</code> 和 <code>y</code> 的操作，就是对调用处 <code>a</code> 和 <code>b</code> 的操作。</p><h3 id="main-函数">main 函数</h3><p>特别的，每个 C/C++ 程序都需要有一个名为 <code>main</code> 的函数。任何程序都将从 <code>main</code> 函数开始运行。</p><blockquote><p><code>main</code> 函数也可以有参数，通过 <code>main</code> 函数的参数，我们可以获得外界传给这个程序的指令（也就是「命令行参数」），以便做出不同的反应。</p></blockquote><p>下面是一段调用了函数（子过程）的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say_happy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;happy!\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;happy!\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;happy!\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">say_happy</span>();<br>    <span class="hljs-built_in">say_happy</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="文件操作">文件操作</h2><h3 id="文件的概念">文件的概念</h3><p>文件是根据特定的目的而收集在一起的有关数据的集合。C/C++ 把每一个文件都看成是一个有序的字节流，每个文件都是以 <strong>文件结束标志</strong>（EOF）结束，如果要操作某个文件，程序应该首先打开该文件，每当一个文件被打开后（请记得关闭打开的文件），该文件就和一个流关联起来，这里的流实际上是一个字节序列。</p><p>C/C++ 将文件分为文本文件和二进制文件。文本文件就是简单的文本文件（重点），另外二进制文件就是特殊格式的文件或者可执行代码文件等。</p><h3 id="文件的操作步骤">文件的操作步骤</h3><ol><li>打开文件，将文件指针指向文件，决定打开文件类型；</li><li>对文件进行读、写操作（比赛中主要用到的操作，其他一些操作暂时不写）；</li><li>在使用完文件后，关闭文件。</li></ol><h3 id="freopen-函数">freopen 函数</h3><h4 id="函数简介">函数简介</h4><p>函数用于将指定输入输出流以指定方式重定向到文件，包含于头文件 <code>stdio.h (cstdio)</code> 中，该函数可以在不改变代码原貌的情况下改变输入输出环境，但使用时应当保证流是可靠的。</p><p>函数主要有三种方式：读、写和附加。</p><h4 id="函数原型">函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FILE* <span class="hljs-title">freopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* mode, FILE* stream)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="参数说明">参数说明</h4><ul><li><code>filename</code>: 要打开的文件名</li><li><code>mode</code>: 文件打开的模式，表示文件访问的权限</li><li><code>stream</code>: 文件指针，通常使用标准文件流 (<code>stdin</code> / <code>stdout</code>) 或标准错误输出流 (<code>stderr</code>)</li><li>返回值：文件指针，指向被打开文件</li></ul><h4 id="文件打开格式">文件打开格式</h4><ul><li><code>r</code>：以只读方式打开文件，文件必须存在，只允许读入数据 <strong>（常用）</strong></li><li><code>r+</code>：以读/写方式打开文件，文件必须存在，允许读/写数据</li><li><code>rb</code>：以只读方式打开二进制文件，文件必须存在，只允许读入数据</li><li><code>rb+</code>：以读/写方式打开二进制文件，文件必须存在，允许读/写数据</li><li><code>rt+</code>：以读/写方式打开文本文件，允许读/写数据</li><li><code>w</code>：以只写方式打开文件，文件不存在会新建文件，否则清空内容，只允许写入数据 <strong>（常用）</strong></li><li><code>w+</code>：以读/写方式打开文件，文件不存在将新建文件，否则清空内容，允许读/写数据</li><li><code>wb</code>：以只写方式打开二进制文件，文件不存在将会新建文件，否则清空内容，只允许写入数据</li><li><code>wb+</code>：以读/写方式打开二进制文件，文件不存在将新建文件，否则清空内容，允许读/写数据</li><li><code>a</code>：以只写方式打开文件，文件不存在将新建文件，写入数据将被附加在文件末尾（保留 EOF 符）</li><li><code>a+</code>：以读/写方式打开文件，文件不存在将新建文件，写入数据将被附加在文件末尾（不保留 EOF 符）</li><li><code>at+</code>：以读/写方式打开文本文件，写入数据将被附加在文件末尾</li><li><code>ab+</code>：以读/写方式打开二进制文件，写入数据将被附加在文件末尾</li></ul><h4 id="使用方法">使用方法</h4><p>读入文件内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;data.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br><span class="hljs-comment">// data.in 就是读取的文件名，要和可执行文件放在同一目录下</span><br></code></pre></td></tr></table></figure><p>输出文件内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;data.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-comment">// data.out 就是输出文件的文件名，和可执行文件在同一目录下</span><br></code></pre></td></tr></table></figure><p>关闭标准输入/输出流：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">fclose</span>(stdin);<br><span class="hljs-built_in">fclose</span>(stdout);<br></code></pre></td></tr></table></figure><p><strong>注</strong>：<code>printf</code> / <code>scanf</code> / <code>cin</code> / <code>cout</code> 等函数默认使用 <code>stdin</code> / <code>stdout</code>，将 <code>stdin</code> / <code>stdout</code> 重定向后，这些函数将输入/输出到被定向的文件。</p><h4 id="模板">模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;data.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;data.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    中间的代码不需要改变，直接使用 cin 和 cout 即可</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">fclose</span>(stdin);<br>    <span class="hljs-built_in">fclose</span>(stdout);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fopen-函数（选读）">fopen 函数（选读）</h3><p>函数大致与 <code>freopen</code> 相同，函数将打开指定文件并返回打开文件的指针。程序设计中不常用到。</p><h4 id="函数原型-2">函数原型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FILE* <span class="hljs-title">fopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* mode)</span></span><br></code></pre></td></tr></table></figure><p>各项参数含义同 <code>freopen</code>。</p><h4 id="可用读写函数（基本）">可用读写函数（基本）</h4><ul><li><code>fread</code> / <code>fwrite</code></li><li><code>fgetc</code> / <code>fputc</code></li><li><code>fscanf</code> / <code>fprintf</code></li><li><code>fgets</code> / <code>fputs</code></li></ul><h4 id="使用方式">使用方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">FILE *in, *out;  <span class="hljs-comment">// 定义文件指针</span><br>in = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.in&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>out = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.out&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">do what you want to do</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">fclose</span>(stdin);<br><span class="hljs-built_in">fclose</span>(stdout);<br></code></pre></td></tr></table></figure><h3 id="C-的-ifstream-ofstream-文件输入输出流">C++ 的 ifstream / ofstream 文件输入输出流</h3><h4 id="使用方法-2">使用方法</h4><p>读入文件内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.in&quot;</span>)</span></span>;<br><span class="hljs-comment">// data.in 就是读取文件的相对位置或绝对位置</span><br></code></pre></td></tr></table></figure><p>输出到文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;data.out&quot;</span>)</span></span>;<br><span class="hljs-comment">// data.out 就是输出文件的相对位置或绝对位置</span><br></code></pre></td></tr></table></figure><p>关闭标准输入/输出流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">fin.<span class="hljs-built_in">close</span>();<br>fout.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><h4 id="模板-2">模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">// 两个类型都在 std 命名空间里</span><br><br><span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.in&quot;</span>)</span></span>;<br><span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;data.out&quot;</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    中间的代码改变 cin 为 fin ，cout 为 fout 即可</span><br><span class="hljs-comment">    */</span><br>    fin.<span class="hljs-built_in">close</span>();<br>    fout.<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="参考资料">参考资料</h2><ul><li>OI Wiki: <a target="_blank" rel="noopener" href="https://oi-wiki.org/">https://oi-wiki.org/</a></li><li>C++ Reference: <a target="_blank" rel="noopener" href="https://zh.cppreference.com/">https://zh.cppreference.com/</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>复合类型包括数组类型、引用类型、指针类型、类类型、函数类型等。由于本文是面向初学者的，故不在本文做具体介绍。具体请参阅 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/type">类型 - cppreference.com</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>详见 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/value_category#.E7.BA.AF.E5.8F.B3.E5.80.BC">值类别 - cppreference</a>。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>不包含宽字符类型、位域和枚举类型，详见 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/implicit_conversion#.E6.95.B4.E5.9E.8B.E8.BD.AC.E6.8D.A2">整型转换 - cppreference</a>。 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>定义一个变量时，除了类型说明符之外，还可以包含其他说明符。详见 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/declarations">声明 - cppreference</a>。 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>更通用的方式是使用第 n 维（dimension）的说法。对于「行优先」的存储形式，数组的第一维长度为 N，第二维长度为 M。 <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>实际上，数据在内存中都可以视作线性存放的，因此在一定的规则下，通过动态开辟一维数组的空间，即可在其上存储 n 维的数组。 <a href="#fnref6" class="footnote-backref">↩︎</a></p></li></ol></section></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="/img/avatar/2.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="/img/avatar/2.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">小嗷犬</div><div class="post-copyright__author_desc">分享技术，记录生活</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.marquis.eu.org/posts/a54c2388/">原创</a><a class="post-copyright-title"><span onclick='rm.copyPageUrl("https://blog.marquis.eu.org/posts/a54c2388/")'>C++ 程序设计入门</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/reward/wechat.png" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.png" alt="WeChat Pay"></a><div class="post-qr-code-desc">WeChat Pay</div></li><li class="reward-item"><a href="/img/reward/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.png" alt="Alipay"></a><div class="post-qr-code-desc">Alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display:none"></div><div class="reward-link mode"><a class="reward-link-button" href="/operate/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.marquis.eu.org/posts/a54c2388/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C++ 程序设计入门&amp;url=https://blog.marquis.eu.org/posts/a54c2388/&amp;pic=https://img-blog.csdnimg.cn/53244566b46c41bb95f2a0e463f21bae.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl(){var e=window.location.href,t=document.createElement("input");t.setAttribute("value",e),document.body.appendChild(t),t.select(),t.setSelectionRange(0,99999),document.execCommand("copy"),document.body.removeChild(t)}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.marquis.eu.org" target="_blank">小嗷犬</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/CPP/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span> CPP<span class="tagsPageCount">5</span></a><a class="post-meta__box__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><span class="tags-punctuation"><i class="anzhiyufont anzhiyu-icon-tag"></i></span> 程序设计<span class="tagsPageCount">11</span></a></div></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/e3d5aec0/"><img class="prev-cover" src="https://img-blog.csdnimg.cn/42ee0601b0744a75a523b99c6bd87888.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Markdown 扩展语法</div></div></a></div><div class="next-post pull-right"><a href="/posts/68d41990/"><img class="next-cover" src="https://img-blog.csdnimg.cn/cf534f91a18045a2810b91d5a5154829.jpeg" onerror='onerror=null,src="/img/friend_404.gif"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MATLAB 投资问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size:1.5rem;margin-right:4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/7468a076/" title="C++ 标准模板库（Standard Template Library，STL）"><img class="cover" src="https://img-blog.csdnimg.cn/50a4b6696d564c70b0d3a820ced6d881.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-21</div><div class="title">C++ 标准模板库（Standard Template Library，STL）</div></div></a></div><div><a href="/posts/48fee057/" title="程序设计 堆"><img class="cover" src="https://img-blog.csdnimg.cn/7a1512cc7bb84b69a881868b8e65fe35.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-08-14</div><div class="title">程序设计 堆</div></div></a></div><div><a href="/posts/9a4021f9/" title="程序设计 树基础"><img class="cover" src="https://img-blog.csdnimg.cn/61e213db503542ac8d7f93df121c37ee.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-08-14</div><div class="title">程序设计 树基础</div></div></a></div><div><a href="/posts/ef3da7a7/" title="程序设计 算法基础"><img class="cover" src="https://img-blog.csdnimg.cn/a43be83e63bd48e4a2d953792f83d9f0.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-07-30</div><div class="title">程序设计 算法基础</div></div></a></div><div><a href="/posts/3a872285/" title="Python 二分查找：bisect库的使用"><img class="cover" src="https://img-blog.csdnimg.cn/6cc76653eb7b45658123dcb4871223e8.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-03-10</div><div class="title">Python 二分查找：bisect库的使用</div></div></a></div><div><a href="/posts/f82fa460/" title="Python 优先队列：heapq库的使用"><img class="cover" src="https://img-blog.csdnimg.cn/6cc76653eb7b45658123dcb4871223e8.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-03-15</div><div class="title">Python 优先队列：heapq库的使用</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i> <span>评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display:none">匿名评论</a><a href="/privacy" style="margin-left:4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src="/img/avatar/2.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-status"><img class="g-status" src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"></div></div><div class="author-info__description"><div style="line-height:1.38;margin:.6rem 0;text-align:justify;color:rgba(255,255,255,.8)">这有关于<b style="color:#fff">语言、算法、AI</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:.6rem 0;text-align:justify;color:rgba(255,255,255,.8)">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">小嗷犬</h1><div class="author-info__desc">分享技术，记录生活</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://marquis.blog.csdn.net/" target="_blank" title="CSDN"><i class="fas fa-c faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://www.kaggle.com/marquis03" target="_blank" title="Kaggle"><i class="fab fa-kaggle faa-tada"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background:url(/img/card_wx/front.png) center center/100% no-repeat"></div><div class="back face" style="background:url(/img/card_wx/back.png) center center/100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B"><span class="toc-number">1.</span> <span class="toc-text">如何开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.</span> <span class="toc-text">环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%88IDE%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">集成开发环境（IDE）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">编译器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA-C-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">第一个 C++ 程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">C++ 语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6"><span class="toc-number">2.1.</span> <span class="toc-text">代码框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-include"><span class="toc-number">2.1.1.</span> <span class="toc-text">什么是 include</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-namespace"><span class="toc-number">2.1.2.</span> <span class="toc-text">什么是 namespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-main-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">什么是 main 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.2.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">2.3.</span> <span class="toc-text">输入与输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cin-%E4%B8%8E-cout"><span class="toc-number">2.3.1.</span> <span class="toc-text">cin 与 cout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scanf-%E4%B8%8E-printf"><span class="toc-number">2.3.2.</span> <span class="toc-text">scanf 与 printf</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9"><span class="toc-number">2.4.</span> <span class="toc-text">扩展内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#endl-%E4%B8%8E-%E2%80%98-n%E2%80%99"><span class="toc-number">2.4.1.</span> <span class="toc-text">endl 与 ‘\n’</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">2.4.2.</span> <span class="toc-text">C++ 中的空白字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#define-%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.3.</span> <span class="toc-text">define 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">布尔类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">整数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.3.</span> <span class="toc-text">字符类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.4.</span> <span class="toc-text">浮点类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.5.</span> <span class="toc-text">无类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E6%8F%90%E5%8D%87"><span class="toc-number">3.2.1.</span> <span class="toc-text">数值提升</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">整数提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%8F%90%E5%8D%87"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">浮点提升</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.2.</span> <span class="toc-text">数值转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">整数转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">浮点转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">浮点整数转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">布尔转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.4.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">常量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97"><span class="toc-number">4.</span> <span class="toc-text">运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">算术运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.1.</span> <span class="toc-text">算术运算中的类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E-%E8%87%AA%E5%87%8F-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">自增&#x2F;自减 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.4.</span> <span class="toc-text">复合赋值运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.5.</span> <span class="toc-text">条件运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.6.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.7.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.8.</span> <span class="toc-text">逗号运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.9.</span> <span class="toc-text">成员访问运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E6%80%BB%E8%A1%A8"><span class="toc-number">4.10.</span> <span class="toc-text">C++ 运算符优先级总表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.1.</span> <span class="toc-text">if 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC-if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">基本 if 语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#if%E2%80%A6else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">if…else 语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#else-if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.1.3.</span> <span class="toc-text">else if 语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.1.2.</span> <span class="toc-text">switch 语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.2.1.</span> <span class="toc-text">for 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.2.2.</span> <span class="toc-text">while 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#do%E2%80%A6while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.2.3.</span> <span class="toc-text">do…while 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">5.2.4.</span> <span class="toc-text">三种循环的联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#break-%E4%B8%8E-continue-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.2.5.</span> <span class="toc-text">break 与 continue 语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">高级数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.1.</span> <span class="toc-text">定义数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">6.1.2.</span> <span class="toc-text">访问数组元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE%E4%B8%8B%E6%A0%87"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">越界访问下标</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.3.</span> <span class="toc-text">多维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">6.2.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">6.2.1.</span> <span class="toc-text">定义结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-%E4%BF%AE%E6%94%B9%E6%88%90%E5%91%98%E5%85%83%E7%B4%A0"><span class="toc-number">6.2.2.</span> <span class="toc-text">访问&#x2F;修改成员元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">6.2.3.</span> <span class="toc-text">结构体的意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">6.2.4.</span> <span class="toc-text">结构体的弊端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">6.3.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%81%E6%8C%87%E9%92%88"><span class="toc-number">6.3.1.</span> <span class="toc-text">变量的地址、指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.2.</span> <span class="toc-text">指针的声明与使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%81%8F%E7%A7%BB"><span class="toc-number">6.3.3.</span> <span class="toc-text">指针的偏移</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%81%8F%E7%A7%BB%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">使用指针偏移访问数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">6.3.4.</span> <span class="toc-text">空指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.5.</span> <span class="toc-text">指针的进阶使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.5.1.</span> <span class="toc-text">指针类型参数的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">6.3.5.2.</span> <span class="toc-text">动态实例化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">6.3.5.3.</span> <span class="toc-text">动态创建数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">6.3.5.4.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">6.3.5.5.</span> <span class="toc-text">动态创建二维数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">6.3.6.</span> <span class="toc-text">指向函数的指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">7.1.</span> <span class="toc-text">函数的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%EF%BC%9A%E7%BC%96%E5%86%99%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text">实现函数：编写函数的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">函数的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main-%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">main 函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">文件的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.2.</span> <span class="toc-text">文件的操作步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#freopen-%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">freopen 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="toc-number">8.3.1.</span> <span class="toc-text">函数简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="toc-number">8.3.2.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">8.3.3.</span> <span class="toc-text">参数说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.3.4.</span> <span class="toc-text">文件打开格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.5.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">8.3.6.</span> <span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fopen-%E5%87%BD%E6%95%B0%EF%BC%88%E9%80%89%E8%AF%BB%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">fopen 函数（选读）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-2"><span class="toc-number">8.4.1.</span> <span class="toc-text">函数原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%94%A8%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89"><span class="toc-number">8.4.2.</span> <span class="toc-text">可用读写函数（基本）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">8.4.3.</span> <span class="toc-text">使用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%9A%84-ifstream-ofstream-%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">8.5.</span> <span class="toc-text">C++ 的 ifstream &#x2F; ofstream 文件输入输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">8.5.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-2"><span class="toc-number">8.5.2.</span> <span class="toc-text">模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">9.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/6062c529/" title="【论文笔记】Sign Language Video Retrieval with Free-Form Textual Queries"><img src="https://i-blog.csdnimg.cn/direct/8440705e97cd474ea81703fa5d0afbae.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="【论文笔记】Sign Language Video Retrieval with Free-Form Textual Queries"></a><div class="content"><a class="title" href="/posts/6062c529/" title="【论文笔记】Sign Language Video Retrieval with Free-Form Textual Queries">【论文笔记】Sign Language Video Retrieval with Free-Form Textual Queries</a><time datetime="2025-01-12T09:51:53.000Z" title="发表于 2025-01-12 17:51:53">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/af8b765f/" title="【论文笔记】PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models"><img src="https://i-blog.csdnimg.cn/direct/6c07a7a5e578400c95f2e6218f53c8ea.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="【论文笔记】PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models"></a><div class="content"><a class="title" href="/posts/af8b765f/" title="【论文笔记】PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models">【论文笔记】PiSSA: Principal Singular Values and Singular Vectors Adaptation of Large Language Models</a><time datetime="2025-01-05T14:30:30.000Z" title="发表于 2025-01-05 22:30:30">2025-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dc5a7551/" title="【论文笔记】Direct Preference Optimization: Your Language Model is Secretly a Reward Model"><img src="https://i-blog.csdnimg.cn/direct/5dca8b5cb9904b4aa94d3a737d2e0295.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="【论文笔记】Direct Preference Optimization: Your Language Model is Secretly a Reward Model"></a><div class="content"><a class="title" href="/posts/dc5a7551/" title="【论文笔记】Direct Preference Optimization: Your Language Model is Secretly a Reward Model">【论文笔记】Direct Preference Optimization: Your Language Model is Secretly a Reward Model</a><time datetime="2025-01-05T13:44:55.000Z" title="发表于 2025-01-05 21:44:55">2025-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5301fcd1/" title="【论文笔记】LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models"><img src="https://i-blog.csdnimg.cn/direct/d8ae3ba314174e979eb534800bca9b6a.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="【论文笔记】LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models"></a><div class="content"><a class="title" href="/posts/5301fcd1/" title="【论文笔记】LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models">【论文笔记】LongLoRA: Efficient Fine-tuning of Long-Context Large Language Models</a><time datetime="2025-01-05T13:00:39.000Z" title="发表于 2025-01-05 21:00:39">2025-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f9e2309d/" title="【论文笔记】NEFTune: Noisy Embeddings Improve Instruction Finetuning"><img src="https://i-blog.csdnimg.cn/direct/fd9354b9f1774dcba4609bf7751e7340.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="【论文笔记】NEFTune: Noisy Embeddings Improve Instruction Finetuning"></a><div class="content"><a class="title" href="/posts/f9e2309d/" title="【论文笔记】NEFTune: Noisy Embeddings Improve Instruction Finetuning">【论文笔记】NEFTune: Noisy Embeddings Improve Instruction Finetuning</a><time datetime="2025-01-05T12:17:40.000Z" title="发表于 2025-01-05 20:17:40">2025-01-05</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://marquis.blog.csdn.net/" title="CSDN"><i class="fas fa-c"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://www.kaggle.com/marquis03" title="Kaggle"><i class="fab fa-kaggle"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/97020105" title="BiliBili"><i class="fab fa-bilibili"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0,500)" src="/img/doge.gif" size="50px"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/Marquis03" title="Github"><i class="fab fa-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://qm.qq.com/q/kvSr7oUR6U" title="QQ"><i class="fab fa-qq"></i></a><a class="deal_link" href="mailto:marquis128@foxmail.com" title="Email"><i class="fas fa-envelope"></i></a></div><div id="workboard"><img class="workSituationImg boardsign" src="/img/footer/小嗷犬-上班摸鱼中-007ACC.svg" alt="距离月入30k也就还差一个大佬带我~" title="距离月入30k也就还差一个大佬带我~"><div id="runtimeTextTip"></div></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="网站收藏" href="/favorites/">网站收藏</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="本站框架为Hexo" title="本站框架为Hexo"><img src="/img/footer/Frame-Hexo-blue.svg" alt="本站框架为Hexo"></a><a class="github-badge" target="_blank" href="https://docs.anheyu.com/" style="margin-inline:5px" data-title="本站主题采用AnZhiYu" title="本站主题采用AnZhiYu"><img src="/img/footer/Theme-AnZhiYu-2E67D3.svg" alt="本站主题采用AnZhiYu"></a><a class="github-badge" target="_blank" href="https://www.netlify.com/" style="margin-inline:5px" data-title="本站部署于Netlify" title="本站部署于Netlify"><img src="/img/footer/Hosted-Netlify-00C7B7.svg" alt="本站部署于Netlify"></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20222350" style="margin-inline:5px" data-title="本站已加入萌ICP豪华套餐，萌ICP备20222350号" title="本站已加入萌ICP豪华套餐，萌ICP备20222350号"><img src="/img/footer/萌ICP备-20222350-fe1384.svg" alt="本站已加入萌ICP豪华套餐，萌ICP备20222350号"></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站源码托管于Github" title="本站源码托管于Github"><img src="/img/footer/Source-Github-d021d6.svg" alt="本站源码托管于Github"></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="/img/footer/Copyright-BY--NC--SA 4.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="/" title="小嗷犬" target="_blank">小嗷犬</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" href="/atom.xml" title="RSS订阅">RSS订阅</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">186</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">3</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://marquis.eu.org/" title="个人主页"><img class="back-menu-item-icon" src="/img/avatar/1.png" alt="个人主页"><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" href="https://blog.marquis.eu.org/" title="个人博客"><img class="back-menu-item-icon" src="/img/avatar/2.png" alt="个人博客"><span class="back-menu-item-text">个人博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size:.9em"></i> <span>归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size:.9em"></i> <span>分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size:.9em"></i> <span>标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/charts/"><i class="fas fa-chart-bar faa-tada"></i> <span>统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8947107806&amp;server=tencent"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size:.9em"></i> <span>音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size:.9em"></i> <span>相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/favorites/"><i class="fas fa-star faa-tada"></i> <span>收藏夹</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size:.9em"></i> <span>装备栏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size:.9em"></i> <span>友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size:.9em"></i> <span>留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size:.9em"></i> <span>关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size:.9em"></i> <span>闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size:.9em"></i> <span>随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size:.88rem">C<sup>1</sup></a><a href="/tags/CPP/" style="font-size:.88rem">CPP<sup>5</sup></a><a href="/tags/LaTeX/" style="font-size:.88rem">LaTeX<sup>4</sup></a><a href="/tags/Linux/" style="font-size:.88rem">Linux<sup>1</sup></a><a href="/tags/MATLAB/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">MATLAB<sup>28</sup></a><a href="/tags/Markdown/" style="font-size:.88rem">Markdown<sup>5</sup></a><a href="/tags/Python/" style="font-size:.88rem;font-weight:500;color:var(--anzhiyu-lighttext)">Python<sup>43</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size:.88rem">前端<sup>1</sup></a><a href="/tags/%E5%8A%A8%E4%BD%9C%E8%AF%86%E5%88%AB/" style="font-size:.88rem">动作识别<sup>2</sup></a><a href="/tags/%E5%A4%9A%E4%BB%BB%E5%8A%A1/" style="font-size:.88rem">多任务<sup>1</sup></a><a href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81/" style="font-size:.88rem">多模态<sup>41</sup></a><a href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" style="font-size:.88rem">大模型<sup>44</sup></a><a href="/tags/%E5%B0%91%E6%A0%B7%E6%9C%AC/" style="font-size:.88rem">少样本<sup>4</sup></a><a href="/tags/%E5%BE%AE%E8%B0%83/" style="font-size:.88rem">微调<sup>11</sup></a><a href="/tags/%E6%89%8B%E8%AF%AD%E7%BF%BB%E8%AF%91/" style="font-size:.88rem">手语翻译<sup>21</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size:.88rem">操作系统<sup>3</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" style="font-size:.88rem">数学建模<sup>20</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" style="font-size:.88rem">数据分析<sup>5</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/" style="font-size:.88rem">数据可视化<sup>2</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size:.88rem">机器学习<sup>8</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size:.88rem">深度学习<sup>19</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size:.88rem">爬虫<sup>5</sup></a><a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" style="font-size:.88rem">程序设计<sup>11</sup></a><a href="/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/" style="font-size:.88rem">论文笔记<sup>66</sup></a></div></div><hr></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8947107806" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.5"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr><div id="algolia-search-results"><div id="algolia-hits"><a class="tag-list" href="/tags/Python" title="Python">Python</a><a class="tag-list" href="/tags/MATLAB" title="MATLAB">MATLAB</a></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size:1rem"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8947107806&quot;, &quot;_blank&quot;);" style="display:none"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>var meting_api="https://api.injahow.cn/meting/?server=:server&type=:type&id=:id&auth=:auth&r=:r"</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script async>!function(){var e,t,n,r,o,i=new Date("01/16/2023 00:00:00"),a=new Date;setInterval((()=>{!function(){a=new Date,o=a.getHours();var l=(a-i)/1e3/60/60/24;e=Math.floor(l);var u=(a-i)/1e3/60/60-24*e;t=Math.floor(u),1==String(t).length&&(t="0"+t);var c=(a-i)/1e3/60-1440*e-60*t;n=Math.floor(c),1==String(n).length&&(n="0"+n);var s=(a-i)/1e3-86400*e-3600*t-60*n;r=Math.round(s),1==String(r).length&&(r="0"+r)}(),function(){if(!document.getElementById("footer"))return;let i="";if(o<18&&o>=9)i=`本站居然运行了 ${e} 天<span id='runtime'> ${t} 小时 ${n} 分 ${r} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;else{let o=document.querySelector("#workboard .workSituationImg");null!=o&&(o.src="/img/footer/小嗷犬-下班摆烂啦-2F2625.svg",o.title="下班了就该开开心心的玩耍，嘿嘿~",o.alt="下班了就该开开心心的玩耍，嘿嘿~"),i=`本站居然运行了 ${e} 天<span id='runtime'> ${t} 小时 ${n} 分 ${r} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`}document.getElementById("runtimeTextTip")&&(document.getElementById("runtimeTextTip").innerHTML=i)}()}),1e3)}()</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.cbd.int/katex@0.16.0/dist/katex.min.css"><script src="https://cdn.cbd.int/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach((a=>{anzhiyu.wrap(a,"div",{class:"katex-wrap"})}))</script><script>(()=>{const t=()=>{"object"==typeof twikoo?setTimeout(o,0):getScript("https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js").then(o)},o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.marquis.eu.org/",region:"",onCommentLoaded:()=>{anzhiyu.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const t=document.getElementById("twikoo-count");t&&twikoo.getCommentsCount({envId:"https://twikoo.marquis.eu.org/",region:"",urls:[window.location.pathname],includeReply:!1}).then((o=>{t.textContent=o[0].count})).catch((t=>{console.error(t)}))})()};t()})()</script><input type="hidden" name="page-type" id="page-type" value="post"><script async src="/js/anzhiyu/comment_barrage.js"></script></div><script>window.addEventListener("load",(()=>{const e=e=>{let t="";if(e.length)for(let n=0;n<e.length;n++){t+="<div class='aside-list-item'>";{const a="data-lazy-src";t+=`<a href='${e[n].url}' class='thumbnail'><img ${a}='${e[n].avatar}' alt='${e[n].nick}'><div class='name'><span>${e[n].nick} </span></div></a>`}t+=`<div class='content'>\n        <a class='comment' href='${e[n].url}' title='${e[n].content}'>${e[n].content}</a>\n        <time datetime="${e[n].date}">${anzhiyu.diffDate(e[n].date,!0)}</time></div>\n        </div>`}else t+="没有评论";let n=document.querySelector("#card-newest-comments .aside-list");n&&(n.innerHTML=t),window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(n)},t=()=>{if(document.querySelector("#card-newest-comments .aside-list")){const t=saveToLocal.get("twikoo-newest-comments");t?e(JSON.parse(t)):(()=>{const t=()=>{twikoo.getRecentComments({envId:"https://twikoo.marquis.eu.org/",region:"",pageSize:6,includeReply:!0}).then((function(t){const n=t.map((e=>{return{content:(t=e.comment,""===t||(t=(t=(t=(t=t.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(t=t.substring(0,150)+"..."),t),avatar:e.avatar,nick:e.nick,url:e.url+"#"+e.id,date:new Date(e.created).toISOString()};var t}));saveToLocal.set("twikoo-newest-comments",JSON.stringify(n),10/1440),e(n)})).catch((function(e){document.querySelector("#card-newest-comments .aside-list").textContent="无法获取评论，请确认相关配置是否正确"}))};"object"==typeof twikoo?t():getScript("https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js").then(t)})()}};t(),document.addEventListener("pjax:complete",t)}))</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script defer src="/js/console.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=['meta[property="og:image"]','meta[property="og:title"]','meta[property="og:url"]','meta[property="og:type"]','meta[property="og:site_name"]','meta[property="og:description"]',"head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(anzhiyu.removeGlobalFnEvent("pjax"),anzhiyu.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>